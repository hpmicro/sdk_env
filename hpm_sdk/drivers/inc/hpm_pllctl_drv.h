/*
 * Copyright (c) 2021,2025 HPMicro
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#ifndef HPM_PLLCTL_DRV_H
#define HPM_PLLCTL_DRV_H
#include "hpm_common.h"
#include "hpm_soc_feature.h"
#include "hpm_pllctl_regs.h"

/**
 *
 * @brief PLLCTL driver APIs
 * @defgroup pllctl_interface PLLCTL driver APIs
 * @{
 */

#define PLLCTL_PLL_VCO_FREQ_MIN (375000000U)
#define PLLCTL_PLL_VCO_FREQ_MAX (2200000000U)

/*
 * @brief PLL parts with lock
 */
#define PLLCTL_PLL_LOCK_SS_RESET PLLCTL_PLL_LOCK_LOCK_SS_RSTPTR_MASK
#define PLLCTL_PLL_LOCK_REFDIV PLLCTL_PLL_LOCK_LOCK_REFDIV_MASK
#define PLLCTL_PLL_LOCK_POSTDIV1 PLLCTL_PLL_LOCK_LOCK_POSTDIV1_MASK
#define PLLCTL_PLL_LOCK_SS_SPREAD PLLCTL_PLL_LOCK_LOCK_SS_SPREAD_MASK
#define PLLCTL_PLL_LOCK_SS_DIVVAL PLLCTL_PLL_LOCK_LOCK_SS_DIVVAL_MASK
#define PLLCTL_PLL_LOCK_ALL (PLLCTL_PLL_LOCK_LOCK_SS_RSTPTR_MASK \
                            | PLLCTL_PLL_LOCK_LOCK_REFDIV_MASK \
                            | PLLCTL_PLL_LOCK_LOCK_POSTDIV1_MASK \
                            | PLLCTL_PLL_LOCK_LOCK_SS_SPREAD_MASK \
                            | PLLCTL_PLL_LOCK_LOCK_SS_DIVVAL_MASK \
                            | PLLCTL_PLL_LOCK_LOCK_SS_DIVVAL_MASK)

/*
 * @brief PLLCTL specific status
 */
enum {
    status_pllctl_not_enabled = MAKE_STATUS(status_group_pllctl, 1),
    status_pllctl_out_of_range = MAKE_STATUS(status_group_pllctl, 2),
};

/*
 * @brief PLLCTL spread spectrum type
 */
typedef enum {
    pllctl_ss_centerspread = 0,
    pllctl_ss_downspread = 1,
} pllctl_ss_type;

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Disables spread spectrum mode for a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @return status_success if spread spectrum is disabled successfully
 * @note Disabling spread spectrum may increase EMI
 */
static inline hpm_stat_t pllctl_pll_ss_disable(PLLCTL_Type *ptr, uint8_t pll)
{
    if (pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1)) {
        return status_invalid_argument;
    }

    ptr->PLL[pll].CFG0 |= (PLLCTL_PLL_CFG0_SS_RSTPTR_MASK
                            | PLLCTL_PLL_CFG0_SS_RESET_MASK);
    ptr->PLL[pll].CFG0 |= PLLCTL_PLL_CFG0_SS_DISABLE_SSCG_MASK;
    return status_success;
}

/**
 * @brief Powers down a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @return status_success if PLL is powered down successfully
 * @note This will stop the clock signals generated by the PLL
 */
static inline hpm_stat_t pllctl_pll_powerdown(PLLCTL_Type *ptr, uint8_t pll)
{
    if (pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1)) {
        return status_invalid_argument;
    }

    ptr->PLL[pll].CFG1 = (ptr->PLL[pll].CFG1 &
            ~(PLLCTL_PLL_CFG1_PLLCTRL_HW_EN_MASK | PLLCTL_PLL_CFG1_CLKEN_SW_MASK))
            | PLLCTL_PLL_CFG1_PLLPD_SW_MASK;
    return status_success;
}

/**
 * @brief Powers on a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @return status_success if PLL is powered on successfully
 * @note The PLL must be properly configured before powering on
 */
static inline hpm_stat_t pllctl_pll_poweron(PLLCTL_Type *ptr, uint8_t pll)
{
    uint32_t cfg;
    if (pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1)) {
        return status_invalid_argument;
    }

    cfg = ptr->PLL[pll].CFG1;
    if (!(cfg & PLLCTL_PLL_CFG1_PLLPD_SW_MASK)) {
        return status_success;
    }

    if (cfg & PLLCTL_PLL_CFG1_PLLCTRL_HW_EN_MASK) {
        ptr->PLL[pll].CFG1 &= ~PLLCTL_PLL_CFG1_PLLCTRL_HW_EN_MASK;
    }

    ptr->PLL[pll].CFG1 &= ~PLLCTL_PLL_CFG1_PLLPD_SW_MASK;

    /*
     * put back to hardware mode
     */
    ptr->PLL[pll].CFG1 |= PLLCTL_PLL_CFG1_PLLCTRL_HW_EN_MASK;
    return status_success;
}

/**
 * @brief Sets the post-divider (postdiv1) for a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] div Post-divider value (1-7)
 * @return status_success if post-divider is set successfully
 * @note The post-divider affects the PLL's output frequency
 */
static inline hpm_stat_t pllctl_set_postdiv1(PLLCTL_Type *ptr, uint8_t pll, uint8_t div)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || (!div)
            || ((div) > (PLLCTL_PLL_CFG0_POSTDIV1_MASK >> PLLCTL_PLL_CFG0_POSTDIV1_SHIFT))) {
        return status_invalid_argument;
    }

    ptr->PLL[pll].CFG0 = ((ptr->PLL[pll].CFG0 & ~(PLLCTL_PLL_CFG0_POSTDIV1_MASK))) | PLLCTL_PLL_CFG0_POSTDIV1_SET(div);
    return status_success;
}

/**
 * @brief Sets the feedback divider for PLL integer mode
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] fbdiv Feedback divider value (0x1~0x1000)
 * @return status_success if feedback divider is set successfully
 * @note Fout = Fref/refdiv * fbdiv / postdiv1
 */
static inline hpm_stat_t pllctl_set_fbdiv_int(PLLCTL_Type *ptr, uint8_t pll, uint16_t fbdiv)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || ((fbdiv - 1) > (uint16_t)(PLLCTL_PLL_CFG2_FBDIV_INT_MASK >> PLLCTL_PLL_CFG2_FBDIV_INT_SHIFT))) {
        return status_invalid_argument;
    }

    ptr->PLL[pll].CFG2 = ((ptr->PLL[pll].CFG2 & ~(PLLCTL_PLL_CFG2_FBDIV_INT_MASK))) | PLLCTL_PLL_CFG2_FBDIV_INT_SET(fbdiv - 1);
    return status_success;
}

/**
 * @brief Sets the feedback divider for PLL fraction mode
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] fbdiv Feedback divider value (0x1~0x1000)
 * @return status_success if feedback divider is set successfully
 */
static inline hpm_stat_t pllctl_set_fbdiv_frac(PLLCTL_Type *ptr, uint8_t pll, uint16_t fbdiv)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || ((fbdiv - 1) > (uint16_t) (PLLCTL_PLL_FREQ_FBDIV_FRAC_MASK >> PLLCTL_PLL_FREQ_FBDIV_FRAC_SHIFT))) {
        return status_invalid_argument;
    }

    ptr->PLL[pll].FREQ = (ptr->PLL[pll].FREQ & ~(PLLCTL_PLL_FREQ_FBDIV_FRAC_MASK))
                        | PLLCTL_PLL_FREQ_FBDIV_FRAC_SET(fbdiv - 1);
    return status_success;
}

/**
 * @brief Sets the fractional part for PLL fraction mode
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] frac 24-bit fractional value (0-2^24-1)
 * @return status_success if fractional value is set successfully
 * @note The PLL must be powered down before changing the fractional value
 */
static inline hpm_stat_t pllctl_set_frac(PLLCTL_Type *ptr, uint8_t pll, uint32_t frac)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || (frac > (PLLCTL_PLL_FREQ_FRAC_MASK >> PLLCTL_PLL_FREQ_FRAC_SHIFT))) {
        return status_invalid_argument;
    }
    ptr->PLL[pll].FREQ = (ptr->PLL[pll].FREQ & ~(PLLCTL_PLL_FREQ_FRAC_MASK))
                        | PLLCTL_PLL_FREQ_FRAC_SET(frac);
    return status_success;
}

/**
 * @brief Gets the current divider value for a specified PLL divider
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to query
 * @param [in] div_index Divider index (0: DIV0, 1: DIV1)
 * @return Current divider value (1-based) or error status
 */
static inline hpm_stat_t pllctl_get_div(PLLCTL_Type *ptr, uint8_t pll, uint8_t div_index)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || !(PLLCTL_SOC_PLL_HAS_DIV0(pll))) {
        return status_invalid_argument;
    }
    if (div_index) {
        return PLLCTL_PLL_DIV0_DIV_GET(ptr->PLL[pll].DIV1) + 1;
    } else {
        return PLLCTL_PLL_DIV0_DIV_GET(ptr->PLL[pll].DIV0) + 1;
    }
}

/**
 * @brief Checks if a specified PLL divider has stabilized
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to check
 * @param [in] div_index Divider index (0: DIV0, 1: DIV1)
 * @return true if divider has stabilized, false otherwise
 */
static inline bool pllctl_div_is_stable(PLLCTL_Type *ptr, uint8_t pll, uint8_t div_index)
{
    uint32_t status;
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1)) || !(PLLCTL_SOC_PLL_HAS_DIV0(pll))) {
        return false;
    }
    if (div_index) {
        status = ptr->PLL[pll].DIV1;
        return (IS_HPM_BITMASK_CLR(status, PLLCTL_PLL_DIV1_ENABLE_MASK)
             || (IS_HPM_BITMASK_CLR(status, PLLCTL_PLL_DIV1_BUSY_MASK) && IS_HPM_BITMASK_SET(status, PLLCTL_PLL_DIV1_RESPONSE_MASK)));
    } else {
        status = ptr->PLL[pll].DIV0;
        return (IS_HPM_BITMASK_CLR(status, PLLCTL_PLL_DIV0_ENABLE_MASK)
             || (IS_HPM_BITMASK_CLR(status, PLLCTL_PLL_DIV0_BUSY_MASK) && IS_HPM_BITMASK_SET(status, PLLCTL_PLL_DIV0_RESPONSE_MASK)));
    }
}

/**
 * @brief Sets the divider value for a specified PLL divider
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] div_index Divider index (0: DIV0, 1: DIV1)
 * @param [in] div Divider value (1-based)
 * @return status_success if divider is set successfully
 */
static inline hpm_stat_t pllctl_set_div(PLLCTL_Type *ptr, uint8_t pll, uint8_t div_index, uint16_t div)
{
    if ((pll > (PLLCTL_SOC_PLL_MAX_COUNT - 1))
            || !(PLLCTL_SOC_PLL_HAS_DIV0(pll))
            || ((div - 1) > (uint16_t) (PLLCTL_PLL_DIV0_DIV_MASK >> PLLCTL_PLL_DIV0_DIV_SHIFT))) {
        return status_invalid_argument;
    }

    if (div_index) {
        ptr->PLL[pll].DIV1 = (ptr->PLL[pll].DIV1 & ~(PLLCTL_PLL_DIV1_DIV_MASK))
                            | PLLCTL_PLL_DIV1_DIV_SET(div - 1);
    } else {
        ptr->PLL[pll].DIV0 = (ptr->PLL[pll].DIV0 & ~(PLLCTL_PLL_DIV0_DIV_MASK))
                            | PLLCTL_PLL_DIV0_DIV_SET(div - 1);
    }
    while (!pllctl_div_is_stable(ptr, pll, div_index)) {
        NOP();
    }
    return status_success;
}

/**
 * @brief Checks if a specified PLL is enabled
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to check
 * @return true if PLL is enabled, false otherwise
 */
static inline bool pllctl_pll_is_enabled(PLLCTL_Type *ptr, uint8_t pll)
{
    return (ptr->PLL[pll].STATUS & PLLCTL_PLL_STATUS_ENABLE_MASK);
}

/**
 * @brief Checks if the crystal oscillator has stabilized
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @return true if crystal oscillator is stable, false otherwise
 */
static inline bool pllctl_xtal_is_stable(PLLCTL_Type *ptr)
{
    uint32_t status = ptr->XTAL;
    return (IS_HPM_BITMASK_CLR(status, PLLCTL_XTAL_ENABLE_MASK)
         || IS_HPM_BITMASK_SET(status, PLLCTL_XTAL_RESPONSE_MASK));
}

/**
 * @brief Checks if the crystal oscillator is enabled
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @return true if crystal oscillator is enabled, false otherwise
 */
static inline bool pllctl_xtal_is_enabled(PLLCTL_Type *ptr)
{
    return ptr->XTAL & PLLCTL_XTAL_ENABLE_MASK;
}

/**
 * @brief Sets the ramp-up time for the crystal oscillator
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] cycles Number of IRC24M clock cycles for ramp-up
 * @note The ramp-up time affects crystal oscillator startup
 */
static inline void pllctl_xtal_set_rampup_time(PLLCTL_Type *ptr, uint32_t cycles)
{
    ptr->XTAL = (ptr->XTAL & ~PLLCTL_XTAL_RAMP_TIME_MASK) | PLLCTL_XTAL_RAMP_TIME_SET(cycles);
}

/**
 * @brief Checks if a specified PLL is locked
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to check
 * @return true if PLL is locked, false otherwise
 */
static inline bool pllctl_pll_is_locked(PLLCTL_Type *ptr, uint8_t pll)
{
    return ((ptr->PLL[pll].STATUS & PLLCTL_PLL_STATUS_PLL_LOCK_COMB_MASK));
}

/**
 * @brief Sets the operating mode of a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] int_mode true for integer mode, false for fractional mode
 * @return status_success if mode is set successfully
 * @note This function will power cycle the PLL if mode change is required
 */
hpm_stat_t pllctl_set_pll_work_mode(PLLCTL_Type *ptr, uint8_t pll, bool int_mode);

/**
 * @brief Sets the reference divider for a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] div Reference divider value (1-63)
 * @return status_success if reference divider is set successfully
 * @note Minimum reference frequency: 1MHz for integer mode, 10MHz for fractional mode
 */
hpm_stat_t pllctl_set_refdiv(PLLCTL_Type *ptr, uint8_t pll, uint8_t div);

/**
 * @brief Initializes a PLL in integer mode for a specific frequency
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] freq_in_hz Desired output frequency in Hertz
 * @return status_success if PLL is initialized successfully
 * @note Output frequency must be between 375MHz and 2.2GHz
 */
hpm_stat_t pllctl_init_int_pll_with_freq(PLLCTL_Type *ptr, uint8_t pll, uint32_t freq_in_hz);

/**
 * @brief Initializes a PLL in fractional mode for a specific frequency
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] freq_in_hz Desired output frequency in Hertz
 * @return status_success if PLL is initialized successfully
 * @note Output frequency must be between 375MHz and 2.2GHz
 */
hpm_stat_t pllctl_init_frac_pll_with_freq(PLLCTL_Type *ptr, uint8_t pll, uint32_t freq_in_hz);

/**
 * @brief Gets the current frequency of a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to query
 * @return Current PLL frequency in Hertz, 0 if PLL is powered down
 */
uint32_t pllctl_get_pll_freq_in_hz(PLLCTL_Type *ptr, uint8_t pll);

/**
 * @brief Enables spread spectrum mode for a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] spread Spread spectrum depth (0.x%)
 * @param [in] div Spread spectrum divider (1-63)
 * @param [in] down_spread true for down-spread, false for center-spread
 * @return status_success if spread spectrum is enabled successfully
 */
hpm_stat_t pllctl_pll_ss_enable(PLLCTL_Type *ptr, uint8_t pll, uint8_t spread, uint8_t div, bool down_spread);

/**
 * @brief Configures spread spectrum settings for a specified PLL
 * @param [in] ptr Base address of the PLLCTL peripheral
 * @param [in] pll Index of the PLL to configure
 * @param [in] ss_range Spread spectrum range (0.x%)
 * @param [in] modulation_freq Desired modulation frequency in Hertz
 * @param [in] ss_type Type of spread spectrum modulation
 * @return status_success if spread spectrum is configured successfully
 */
hpm_stat_t pllctl_pll_setup_spread_spectrum(PLLCTL_Type *ptr, uint8_t pll, uint8_t ss_range, uint32_t modulation_freq, pllctl_ss_type ss_type);
#ifdef __cplusplus
}
#endif
/**
 * @}
 */
#endif /* HPM_PLLCTL_DRV_H */
