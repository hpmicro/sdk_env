<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3. I2C Component &mdash; HPMicro Software Development Kit  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4. SPI Component" href="../spi/README_en.html" />
    <link rel="prev" title="2. PLB Filter Component" href="../plb/filter/README_en.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/index_en.html">Evaluation Boards</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index_en.html">Components</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../ppi/README_en.html">1. PPI Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plb/filter/README_en.html">2. PLB Filter Component</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3. I2C Component</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">3.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#introduction-to-relevant-enumerations-and-structures">3.2. Introduction to Relevant Enumerations and Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-call-flow-introduction">3.3. API Call Flow Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-an-i2c-instance-variable">3.3.1. Defining an I2C Instance Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-i2c-instance-variable">3.3.2. Default I2C Instance Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i2c-initialization">3.3.3. I2C Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-configuration">3.3.4. DMA Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#read-and-write-operations">3.3.5. Read and Write Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#blocking-read-and-write-operations">3.3.6. Blocking Read and Write Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-blocking-read-and-write-operations">3.3.7. Non-blocking Read and Write Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#notes">3.4. Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../spi/README_en.html">4. SPI Component</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/index_en.html">Samples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/drivers/index_en.html">Drivers Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/cmake_intro.html">SDK CMake API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_doc.html">SDK API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HPMicro Software Development Kit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index_en.html">Components</a></li>
      <li class="breadcrumb-item active"><span class="section-number">3. </span>I2C Component</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/components/i2c/README_en.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="i2c-component">
<span id="id1"></span><h1><span class="section-number">3. </span>I2C Component<a class="headerlink" href="#i2c-component" title="Permalink to this heading"></a></h1>
<section id="overview">
<h2><span class="section-number">3.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>The I2C component provides a higher-level API compared to the driver layer for configuring, initializing, and operating the I2C bus. It supports multiple I2C devices and offers both blocking and non-blocking data transfer functionalities. Below are the primary features of this component:</p>
<ul>
<li><p>Multi-instance support
- Supports multiple I2C instances (such as I2C0, I2C1, etc.), each with independent configuration parameters.
- Manages configuration information for each I2C instance through the <cite>hpm_i2c_context_t</cite> structure, including address mode, speed mode, master/slave mode.</p></li>
<li><p>Blocking and non-blocking read/write operation interfaces
- Supports both master and slave modes.
- Provides non-blocking read/write functions.
- Provides blocking read/write functions with timeout mechanisms to ensure timely error status returns in case of prolonged unresponsiveness.</p></li>
</ul>
</li>
</ul>
</section>
<section id="introduction-to-relevant-enumerations-and-structures">
<h2><span class="section-number">3.2. </span>Introduction to Relevant Enumerations and Structures<a class="headerlink" href="#introduction-to-relevant-enumerations-and-structures" title="Permalink to this heading"></a></h2>
<ul>
<li><p>Enumerations Introduction
- I2C speed enumeration type, this enumeration defines three different I2C communication speed options: standard mode (100kHz), fast mode (400kHz), and fast plus mode (1MHz).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">i2c_speed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">i2c_speed_100khz</span><span class="p">,</span><span class="w">  </span><span class="cm">/* Standard mode (100kHz) */</span>
<span class="w">    </span><span class="n">i2c_speed_400khz</span><span class="p">,</span><span class="w">  </span><span class="cm">/* Fast mode (400kHz) */</span>
<span class="w">    </span><span class="n">i2c_speed_1Mhz</span><span class="p">,</span><span class="w">    </span><span class="cm">/* Fast plus mode (1MHz) */</span>
<span class="p">}</span><span class="w"> </span><span class="n">hpm_i2c_speed_t</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>I2C communication mode enumeration type, defining two communication modes: master mode and slave mode.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">i2c_communication_mode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">i2c_master</span><span class="p">,</span>
<span class="w">    </span><span class="n">i2c_slave</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">hpm_i2c_communication_mode_t</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Address byte order enumeration type, this enumeration defines two different register address byte order options under master mode: little-endian and big-endian.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">i2c_master_addr_endianness</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">i2c_master_addr_little_endian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="cm">/* Little endian */</span>
<span class="w">    </span><span class="n">i2c_master_addr_big_endian</span><span class="p">,</span><span class="w">         </span><span class="cm">/* Big endian */</span>
<span class="p">}</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_endianness_t</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Structures Introduction</p>
<ul class="simple">
<li><p>Initialization configuration structure, containing information such as communication mode, speed, whether to use 10-bit addressing, and slave device address.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_initialize_config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hpm_i2c_communication_mode_t</span><span class="w"> </span><span class="n">communication_mode</span><span class="p">;</span><span class="w"> </span><span class="cm">/* I2C communication mode */</span>
<span class="w">    </span><span class="n">hpm_i2c_speed_t</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span><span class="w">                           </span><span class="cm">/* I2C communication speed */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_10bit_addressing</span><span class="p">;</span><span class="w">                        </span><span class="cm">/* Whether to use 10-bit addressing */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">slave_address</span><span class="p">;</span><span class="w">                           </span><span class="cm">/* Slave device address, only supported in slave mode */</span>
<span class="p">}</span><span class="w"> </span><span class="n">hpm_i2c_initialize_config_t</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>I2C context structure, containing members such as the I2C instance handle and initialization configuration. This structure needs to be defined in applications to save the I2C instance handle and initialization configuration.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_context_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">I2C_Type</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">;</span><span class="w">                                  </span><span class="cm">/* Pointer to the I2C base register */</span>
<span class="w">    </span><span class="n">hpm_i2c_initialize_config_t</span><span class="w"> </span><span class="n">init_config</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Initialization configuration */</span>
<span class="w">    </span><span class="n">hpm_i2c_master_addr_endianness_t</span><span class="w"> </span><span class="n">addr_endianness</span><span class="p">;</span><span class="cm">/* Master address endianness */</span>
<span class="p">}</span><span class="w"> </span><span class="n">hpm_i2c_context_t</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="api-call-flow-introduction">
<h2><span class="section-number">3.3. </span>API Call Flow Introduction<a class="headerlink" href="#api-call-flow-introduction" title="Permalink to this heading"></a></h2>
<section id="defining-an-i2c-instance-variable">
<h3><span class="section-number">3.3.1. </span>Defining an I2C Instance Variable<a class="headerlink" href="#defining-an-i2c-instance-variable" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Define an instance of the <cite>hpm_i2c_context_t</cite> structure. For example, use the <cite>i2c_context</cite> instance variable in the sample.</p></li>
</ul>
</section>
<section id="default-i2c-instance-variable">
<h3><span class="section-number">3.3.2. </span>Default I2C Instance Variable<a class="headerlink" href="#default-i2c-instance-variable" title="Permalink to this heading"></a></h3>
<ul>
<li><p>Use the <cite>hpm_i2c_get_default_init_context</cite> API to initialize the <cite>i2c_context</cite> instance variable by assigning it to the <cite>context</cite> parameter of the API.</p>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_get_default_init_context</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hpm_i2c_get_default_init_context</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>This function sets each member to default values:
- 7-bit address mode
- Master mode
- 100kHz speed
- Little-endian for address register transmission</p></li>
</ul>
</li>
</ul>
</section>
<section id="i2c-initialization">
<h3><span class="section-number">3.3.3. </span>I2C Initialization<a class="headerlink" href="#i2c-initialization" title="Permalink to this heading"></a></h3>
<ul>
<li><p>Call the <cite>hpm_i2c_initialize</cite> API to initialize the I2C. During this process, the parameters of the <cite>i2c_context</cite> instance variable are assigned to the <cite>context</cite> and take effect.</p></li>
<li><p>Prototype of <cite>hpm_i2c_initialize</cite> API:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hpm_i2c_initialize</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>Example</strong>: Instantiate I2C0, set I2C0 to master mode, 1MHz speed, 7-bit address mode, and use big-endian for address register transmission.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_speed_1Mhz</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">communication_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_master</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">is_10bit_addressing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HPM_I2C0</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">addr_endianness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_master_addr_big_endian</span><span class="p">;</span>
<span class="n">hpm_i2c_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>Example</strong>: Instantiate I2C0, set I2C0 to slave mode, 1MHz speed, 10-bit address mode, with a slave device address of 0x16.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_speed_1Mhz</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">communication_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_slave</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">is_10bit_addressing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">init_config</span><span class="p">.</span><span class="n">slave_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x16</span><span class="p">;</span>
<span class="n">i2c_context</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HPM_I2C0</span><span class="p">;</span>
<span class="n">hpm_i2c_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="dma-configuration">
<h3><span class="section-number">3.3.4. </span>DMA Configuration<a class="headerlink" href="#dma-configuration" title="Permalink to this heading"></a></h3>
<ul>
<li><p>If using non-blocking read/write interfaces, this step is required.</p></li>
<li><p>Use the <cite>hpm_i2c_dma_mgr_install_callback</cite> API to initialize DMA and register a callback function. When using non-blocking APIs for data transmission, this function must be called. If no callback function is needed, NULL can be passed as the callback argument.</p></li>
<li><p>The main function of this function is to install the user-provided DMA transfer completion callback into the given I2C context. This ensures that after the DMA transfer completes, the system automatically calls the user’s callback function for subsequent processing.</p></li>
<li><p>Prototype of <cite>hpm_i2c_dma_mgr_install_callback</cite> API:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_dma_mgr_install_callback</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">hpm_i2c_dma_complete_cb</span><span class="w"> </span><span class="n">complete</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>complete</cite></p></td>
<td><p><cite>hpm_i2c_dma_complete_cb</cite></p></td>
<td><p>Pointer to the callback function for DMA transfer completion. Called when the DMA transfer ends.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: Success</p></li>
<li><p><cite>status_invalid_argument</cite>: Invalid argument</p></li>
<li><p><cite>status_fail</cite>: Other errors</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Example</strong>: How to use the <cite>hpm_i2c_dma_mgr_install_callback</cite> function to register a callback function</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define the callback function */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">my_dma_complete_callback</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">channel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;DMA transfer on channel %d completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Initialize I2C context... Not listed here */</span>

<span class="w">    </span><span class="cm">/* Register DMA transfer completion callback */</span>
<span class="w">    </span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_dma_install_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span><span class="w"> </span><span class="n">my_dma_complete_callback</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Callback installed successfully.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/* Continue with DMA setup and start transmission... */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to install callback. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* TODO */</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="read-and-write-operations">
<h3><span class="section-number">3.3.5. </span>Read and Write Operations<a class="headerlink" href="#read-and-write-operations" title="Permalink to this heading"></a></h3>
</section>
<section id="blocking-read-and-write-operations">
<h3><span class="section-number">3.3.6. </span>Blocking Read and Write Operations<a class="headerlink" href="#blocking-read-and-write-operations" title="Permalink to this heading"></a></h3>
<section id="master-mode-divided-into-direct-read-write-operations-and-address-register-read-write-operations">
<h4><span class="section-number">3.3.6.1. </span>Master Mode, Divided into Direct Read/Write Operations and Address Register Read/Write Operations<a class="headerlink" href="#master-mode-divided-into-direct-read-write-operations-and-address-register-read-write-operations" title="Permalink to this heading"></a></h4>
<ul>
<li><p><strong>Direct Read/Write Operations</strong>: Used for blocking read/write operations in I2C master mode. It will wait until data transmission is completed or a timeout occurs.</p></li>
<li><p>These operations are divided into <cite>hpm_i2c_master_write_blocking</cite> and <cite>hpm_i2c_master_read_blocking</cite> APIs.</p>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_write_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_write_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device to which data will be written. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing data to be sent</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Number of bytes to send from the buffer</p></td>
</tr>
<tr class="row-even"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation does not complete within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the write operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided <cite>size</cite> exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation does not complete within the specified <cite>timeout</cite>.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
<li><p><cite>status_i2c_transmit_not_completed</cite>: If the data counter does not match expectations before the transmission ends.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device sending some data to a slave device via the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define the I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Data to be sent and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span><span class="w"> </span><span class="cm">/* Example data */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">);</span><span class="w"> </span><span class="c1">// Data size</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Timeout set to 1 second */</span>
<span class="cm">/* Initialize I2C context... Not listed here */</span>
<span class="cm">/* Use the hpm_i2c_master_write_blocking function to read data from the device */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_write_blocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">data_to_send</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="n">timeout</span>
<span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Write successful */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data successfully written to I2C slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Write failed, handle error case */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to write data to I2C slave. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_read_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_read_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device from which data will be read. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Expected number of bytes to receive in the buffer</p></td>
</tr>
<tr class="row-even"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation does not complete within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the read operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided <cite>size</cite> exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation does not complete within the specified <cite>timeout</cite>.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
<li><p><cite>status_i2c_transmit_not_completed</cite>: If the data counter does not match expectations before the transmission ends.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device reading some data from a slave device via the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define the I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Prepare the receive buffer and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Receive buffer */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Buffer size */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Timeout set to 1 second */</span>
<span class="cm">/* Initialize I2C context... Not listed here */</span>
<span class="cm">/* Use the hpm_i2c_master_read_blocking function to read data from the device */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_read_blocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">received_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="n">timeout</span>
<span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Read successful */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data successfully read from I2C slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Process received_data here */</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Read failed, handle error case */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to read data from I2C slave. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p><strong>Address Register Read/Write Operations</strong>: Used for blocking operations in I2C master mode to write addresses and data to slave devices. It will wait until both address and data transmissions are completed or a timeout occurs.</p></li>
<li><p>These operations are divided into <cite>hpm_i2c_master_addr_write_blocking</cite> and <cite>hpm_i2c_master_addr_read_blocking</cite> APIs.</p>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_addr_write_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_write_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device to which data will be written. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>addr</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Internal register or memory address of the slave device where the write operation will take place</p></td>
</tr>
<tr class="row-odd"><td><p><cite>addr_size</cite></p></td>
<td><p><cite>uint8_t</cite></p></td>
<td><p>Size of the address <cite>addr</cite> in bytes, typically 1 to 4 bytes</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing data to be sent</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf_size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Number of bytes to send from the buffer</p></td>
</tr>
<tr class="row-even"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation does not complete within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the write operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided <cite>addr_size</cite> or <cite>buf_size</cite> do not meet requirements, or if the total data length exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation does not complete within the specified <cite>timeout</cite>.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device writing some data to a specific register of a slave device via the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Data to be sent and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span><span class="w"> </span><span class="cm">/* Example data */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Target register address */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Register address size is 1 byte */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">);</span><span class="w"> </span><span class="c1">// Data size</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Timeout set to 1 second */</span>
<span class="cm">/* Initialize I2C context... Not listed here */</span>
<span class="cm">/* Use the hpm_i2c_master_write_blocking function to write data to the device */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_write_blocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr_size</span><span class="p">,</span>
<span class="w">    </span><span class="n">data_to_send</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="n">timeout</span>
<span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Write successful</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data successfully written to I2C slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Write failed, handle error case</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to write data to I2C slave. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_addr_read_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_read_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device from which data will be read. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>addr</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Internal register or memory address of the slave device where the read operation will take place</p></td>
</tr>
<tr class="row-odd"><td><p><cite>addr_size</cite></p></td>
<td><p><cite>uint8_t</cite></p></td>
<td><p>Size of the address <cite>addr</cite> in bytes, typically 1 to 4 bytes</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf_size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Expected number of bytes to receive in the buffer</p></td>
</tr>
<tr class="row-even"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation does not complete within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the read operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided <cite>addr_size</cite> or <cite>buf_size</cite> do not meet requirements, or if the total data length exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation does not complete within the specified <cite>timeout</cite>.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device reading some data from a specific register of a slave device via the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define the I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address, modify according to actual device */</span>

<span class="cm">/* Data to be read and related information */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Receive buffer size, adjust as needed */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Target register address, modify as needed */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Register address size is 1 byte */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Data size */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Timeout set to 1 second */</span>

<span class="cm">/* Initialize I2C context... Not listed here */</span>

<span class="cm">/* Use the assumed hpm_i2c_master_addr_read_blocking function to read data from the device */</span>
<span class="cm">/* Note: Here it is assumed there exists a function named hpm_i2c_master_addr_read_blocking that allows specifying a register address */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_read_blocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr_size</span><span class="p">,</span>
<span class="w">    </span><span class="n">received_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="n">timeout</span>
<span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Read successful</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data successfully read from I2C slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received byte %d: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Read failed, handle error case</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to read data from I2C slave. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="slave-mode">
<h4><span class="section-number">3.3.6.2. </span>Slave Mode<a class="headerlink" href="#slave-mode" title="Permalink to this heading"></a></h4>
<ul>
<li><p>Used for blocking read/write operations in I2C slave mode. It will wait until data transmission is completed or a timeout occurs.</p></li>
<li><p>These operations are divided into <cite>hpm_i2c_slave_write_blocking</cite> and <cite>hpm_i2c_slave_read_blocking</cite> APIs.</p>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_slave_write_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_slave_write_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing data to be sent</p></td>
</tr>
<tr class="row-even"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Number of bytes to send from the buffer</p></td>
</tr>
<tr class="row-odd"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation is not completed within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the write operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided size exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation is not completed within the specified timeout.</p></li>
<li><p><cite>status_i2c_transmit_not_completed</cite>: If the data counter does not match expectations before the end of the transmission.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C slave device wants to respond to a write request from a master device and send some data:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="cm">/* Initialize I2C context... */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_slave_write_blocking</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">),</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="cm">/* Successfully handled the write request */</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Handle error condition */</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_slave_read_blocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_slave_read_blocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored</p></td>
</tr>
<tr class="row-even"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Expected number of bytes to receive in the buffer</p></td>
</tr>
<tr class="row-odd"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout in milliseconds. If the operation is not completed within this time, the function will return a timeout error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the read operation completes successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided size exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_timeout</cite>: If the operation is not completed within the specified timeout.</p></li>
<li><p><cite>status_i2c_transmit_not_completed</cite>: If the data counter does not match expectations before the end of the transmission.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C slave device wants to respond to a read request from a master device and receive some data:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="cm">/* Initialize I2C context... */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_slave_read_blocking</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">),</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="cm">/* Successfully handled the read request */</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Handle error condition */</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="non-blocking-read-and-write-operations">
<h3><span class="section-number">3.3.7. </span>Non-blocking Read and Write Operations<a class="headerlink" href="#non-blocking-read-and-write-operations" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Used for non-blocking read/write operations in I2C master and slave modes. It allows continuing with other tasks without waiting for the operation to complete.</p></li>
<li><p>Before using non-blocking read/write interfaces, the <strong>DMA Configuration</strong> process mentioned above must be completed.</p></li>
</ul>
<section id="id2">
<h4><span class="section-number">3.3.7.1. </span>Master Mode, Divided into Direct Read/Write Operations and Address Register Read/Write Operations<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h4>
<ul>
<li><p><strong>Direct Read/Write Operations</strong>: Used for non-blocking read/write operations in I2C master mode.</p></li>
<li><p>These operations are divided into <cite>hpm_i2c_master_write_nonblocking</cite> and <cite>hpm_i2c_master_read_nonblocking</cite> APIs.</p>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_write_nonblocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_write_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device to which data will be written. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing data to be sent</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Number of bytes to send from the buffer</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the write operation starts successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided size exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device wants to send some data to a slave device over the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Data to send and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span><span class="w"> </span><span class="cm">/* Example data */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">);</span><span class="w"> </span><span class="c1">// Data size</span>
<span class="cm">/* Initialize I2C context... Not listed here */</span>
<span class="cm">/* DMA configuration... Not listed here */</span>
<span class="cm">/* Use hpm_i2c_master_read_blocking function to read data from the device */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_write_nonblocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">data_to_send</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span>
<span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data transmission started successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to start data transmission. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO Since this is a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, wait for this transmission to complete */</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Prototype of <cite>hpm_i2c_master_read_nonblocking</cite> API:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_read_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to the I2C context structure containing configuration and status</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>Address of the target slave device from which data will be read. This value can be 7-bit or 10-bit based on the <cite>is_10bit_addressing</cite> flag in initialization configuration</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Expected number of bytes to receive in the buffer</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><cite>status_success</cite>: If the read operation starts successfully.</p></li>
<li><p><cite>status_invalid_argument</cite>: If the provided size exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><cite>status_i2c_no_addr_hit</cite>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device wants to read some data from a slave device over the I2C bus:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Prepare buffer for receiving data and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Buffer for received data */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Buffer size */</span>
<span class="cm">/* Initialize I2C context... Not listed here */</span>
<span class="cm">/* DMA configuration... Not listed here */</span>
<span class="cm">/* Use hpm_i2c_master_read_blocking function to read data from the device */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_read_nonblocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">received_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span>
<span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data transmission started successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to start data transmission. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO Since this is a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, wait for this transmission to complete */</span>
</pre></div>
</div>
</li>
<li><p><strong>Non-blocking Operation with Address Register Read/Write</strong>: Used for non-blocking operations to write addresses and data to slave devices in I2C master mode.</p></li>
<li><p>Divided into <code class="docutils literal notranslate"><span class="pre">hpm_i2c_master_addr_write_nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">hpm_i2c_master_addr_read_nonblocking</span></code> APIs</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hpm_i2c_master_addr_write_nonblocking</span></code> API function prototype:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_write_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buf_size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to an I2C context structure that contains I2C configuration information and status.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>The address of the target slave device to which data will be written. Depending on the is_10bit_addressing flag in the initialization configuration, this value can be either 7-bit or 10-bit.</p></td>
</tr>
<tr class="row-even"><td><p><cite>addr</cite></p></td>
<td><p><cite>uint8_t</cite></p></td>
<td><p>The register or memory address within the slave device where the write operation will take place.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>addr_size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The byte size of the address <cite>addr</cite>, typically ranging from 1 to 4 bytes.</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing the data to send.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The number of bytes to send from the buffer.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status_success</span></code>: If the write operation completes successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_invalid_argument</span></code>: If the provided <cite>addr_size</cite> or <cite>buf_size</cite> does not meet requirements, or if the total data length exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_i2c_no_addr_hit</span></code>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device writing some data to a register of a slave device over the I2C bus.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address */</span>
<span class="cm">/* Data to send and its size */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span><span class="w"> </span><span class="cm">/* Example data */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Target register address */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Size of register address is 1 byte */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">);</span><span class="w"> </span><span class="c1">// Size of data</span>
<span class="cm">/* Initialize I2C context... Not shown here */</span>
<span class="cm">/* Configure DMA... Not shown here */</span>

<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_write_nonblocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr_size</span><span class="p">,</span>
<span class="w">    </span><span class="n">data_to_send</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span>
<span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data transmission started successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to start data transmission. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO Since it&#39;s a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, waiting for this transmission to complete. */</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hpm_i2c_master_addr_read_nonblocking</span></code> API function prototype:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_read_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buf_size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to an I2C context structure that contains I2C configuration information and status.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>device_address</cite></p></td>
<td><p><cite>uint16_t</cite></p></td>
<td><p>The address of the target slave device from which data will be read. Depending on the is_10bit_addressing flag in the initialization configuration, this value can be either 7-bit or 10-bit.</p></td>
</tr>
<tr class="row-even"><td><p><cite>addr</cite></p></td>
<td><p><cite>uint8_t</cite></p></td>
<td><p>The register or memory address within the slave device where the read operation will take place.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>addr_size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The byte size of the address <cite>addr</cite>, typically ranging from 1 to 4 bytes.</p></td>
</tr>
<tr class="row-even"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The expected number of bytes to receive in the buffer.</p></td>
</tr>
<tr class="row-even"><td><p><cite>timeout</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>Timeout period in milliseconds. If the operation is not completed within this time, the function will return a timeout error.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status_success</span></code>: If the read operation completes successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_invalid_argument</span></code>: If the provided <cite>addr_size</cite> or <cite>buf_size</cite> does not meet requirements, or if the total data length exceeds the maximum transfer count supported by the hardware.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_timeout</span></code>: If the operation is not completed within the specified timeout period.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_i2c_no_addr_hit</span></code>: If no device responds at the target address.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C master device reading some data from a register of a slave device over the I2C bus.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Define I2C context and device address */</span>
<span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">i2c_context</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3C</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Example slave device address, modify according to actual device */</span>

<span class="cm">/* Data to be read and related information */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Buffer size for receiving data, adjust as needed */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Target register address, modify as needed */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Register address size is 1 byte */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Data size */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Set timeout to 1 second */</span>

<span class="cm">/* Initialize I2C context... Not shown here */</span>

<span class="cm">/* Use the assumed hpm_i2c_master_addr_read_nonblocking function to read data from the device */</span>
<span class="cm">/* Note: Here it is assumed there exists a function named hpm_i2c_master_addr_read_nonblocking that allows specifying a register address */</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_master_addr_read_nonblocking</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">i2c_context</span><span class="p">,</span>
<span class="w">    </span><span class="n">device_address</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr</span><span class="p">,</span>
<span class="w">    </span><span class="n">addr_size</span><span class="p">,</span>
<span class="w">    </span><span class="n">received_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">size</span>
<span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Read successful</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data successfully read from I2C slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received byte %d: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Read failed, handle error case</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to read data from I2C slave. Error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO Since it&#39;s a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, waiting for this transmission to complete. */</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id3">
<h4><span class="section-number">3.3.7.2. </span>Slave Mode<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h4>
<ul>
<li><p>Used for blocking read and write operations under I2C slave mode. It will wait until data transmission completes or times out.</p></li>
<li><p>Divided into <code class="docutils literal notranslate"><span class="pre">hpm_i2c_slave_write_nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">hpm_i2c_slave_read_nonblocking</span></code> APIs</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hpm_i2c_slave_write_nonblocking</span></code> API function prototype:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_slave_write_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to an I2C context structure that contains I2C configuration information and status.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer containing the data to send.</p></td>
</tr>
<tr class="row-even"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The number of bytes to send from the buffer.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status_success</span></code>: If the write operation completes successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_invalid_argument</span></code>: If the provided <cite>size</cite> exceeds the maximum transfer count supported by the hardware.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C slave device wanting to respond to a write request from a master device and send some data:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="cm">/* Initialize I2C context... */</span>
<span class="cm">/* Configure DMA... Not shown here */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">};</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_slave_write_nonblocking</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">data_to_send</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">));</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="cm">/* Successfully processed the write request */</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Handle error condition */</span>
<span class="p">}</span>
<span class="cm">/* TODO Since it&#39;s a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, waiting for this transmission to complete. */</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hpm_i2c_slave_read_nonblocking</span></code> API function prototype:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">hpm_i2c_slave_read_nonblocking</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>Parameter Description</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>context</cite></p></td>
<td><p><cite>hpm_i2c_context_t*</cite></p></td>
<td><p>Pointer to an I2C context structure that contains I2C configuration information and status.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>buf</cite></p></td>
<td><p><cite>uint8_t*</cite></p></td>
<td><p>Pointer to the buffer where received data will be stored.</p></td>
</tr>
<tr class="row-even"><td><p><cite>size</cite></p></td>
<td><p><cite>uint32_t</cite></p></td>
<td><p>The expected number of bytes to receive in the buffer.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p>Return Values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status_success</span></code>: If the read operation completes successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_invalid_argument</span></code>: If the provided <cite>size</cite> exceeds the maximum transfer count supported by the hardware.</p></li>
</ul>
</li>
<li><p><strong>Example</strong>: An I2C slave device wanting to respond to a read request from a master device and receive some data:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="cm">/* Initialize I2C context... */</span>
<span class="cm">/* Configure DMA... Not shown here */</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">hpm_stat_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hpm_i2c_slave_read_nonblocking</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">received_data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_data</span><span class="p">));</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="cm">/* Successfully processed the read request */</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Handle error condition */</span>
<span class="p">}</span>
<span class="cm">/* TODO Since it&#39;s a non-blocking operation, the function returns immediately, allowing the program to continue executing other tasks. For example, waiting for this transmission to complete. */</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>
<section id="notes">
<h2><span class="section-number">3.4. </span>Notes<a class="headerlink" href="#notes" title="Permalink to this heading"></a></h2>
<ul>
<li><p>Since the I2C component uses the DMA manager component, the DMA channel configurations are allocated by the DMA manager. When using DMA, ensure that the allocated DMA channels do not conflict with those used by the I2C component.</p></li>
<li><p>The DMA channels used by the I2C component can be obtained by calling the <cite>hpm_i2c_get_dma_mgr_resource</cite> API.</p>
<ul class="simple">
<li><p><cite>hpm_i2c_get_dma_mgr_resource</cite> API function prototype:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dma_resource_t</span><span class="w"> </span><span class="o">*</span><span class="n">hpm_i2c_get_dma_mgr_resource</span><span class="p">(</span><span class="n">hpm_i2c_context_t</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2025, HPMicro.
      <span class="lastupdated">Last updated on Mar 31, 2025.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>