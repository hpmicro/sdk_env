<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="logo.ico">
<title>HPM SDK: soc/HPM6800/ip/hpm_usb_regs.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://www.hpmicro.com/"
     target="_blank"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 1em;">
   <div id="projectname">HPM SDK
   </div>
   <div id="projectbrief">HPMicro Software Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('HPM6800_2ip_2hpm__usb__regs_8h_source.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">hpm_usb_regs.h</div></div>
</div><!--header-->
<div class="contents">
<a href="HPM6800_2ip_2hpm__usb__regs_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/*</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * Copyright (c) 2021-2024 HPMicro</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> *</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> * SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> *</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> */</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span> </div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span> </div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="preprocessor">#ifndef HPM_USB_H</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="preprocessor">#define HPM_USB_H</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span> </div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span>    __R  uint8_t  RESERVED0[128];              <span class="comment">/* 0x0 - 0x7F: Reserved */</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span>    __RW uint32_t GPTIMER0LD;                  <span class="comment">/* 0x80: General Purpose Timer #0 Load Register */</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span>    __RW uint32_t GPTIMER0CTRL;                <span class="comment">/* 0x84: General Purpose Timer #0 Controller Register */</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span>    __RW uint32_t GPTIMER1LD;                  <span class="comment">/* 0x88: General Purpose Timer #1 Load Register */</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span>    __RW uint32_t GPTIMER1CTRL;                <span class="comment">/* 0x8C: General Purpose Timer #1 Controller Register */</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span>    __RW uint32_t SBUSCFG;                     <span class="comment">/* 0x90: System Bus Config Register */</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span>    __R  uint8_t  RESERVED1[172];              <span class="comment">/* 0x94 - 0x13F: Reserved */</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span>    __RW uint32_t USBCMD;                      <span class="comment">/* 0x140: USB Command Register */</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span>    __RW uint32_t USBSTS;                      <span class="comment">/* 0x144: USB Status Register */</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span>    __RW uint32_t USBINTR;                     <span class="comment">/* 0x148: Interrupt Enable Register */</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span>    __RW uint32_t FRINDEX;                     <span class="comment">/* 0x14C: USB Frame Index Register */</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span>    __R  uint8_t  RESERVED2[4];                <span class="comment">/* 0x150 - 0x153: Reserved */</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span>    <span class="keyword">union </span>{</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span>        __RW uint32_t DEVICEADDR;              <span class="comment">/* 0x154: Device Address Register */</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span>        __RW uint32_t PERIODICLISTBASE;        <span class="comment">/* 0x154: Frame List Base Address Register */</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>    };</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>    <span class="keyword">union </span>{</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span>        __RW uint32_t ASYNCLISTADDR;           <span class="comment">/* 0x158: Next Asynch. Address Register */</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>        __RW uint32_t ENDPTLISTADDR;           <span class="comment">/* 0x158: Endpoint List Address Register */</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>    };</div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span>    __R  uint8_t  RESERVED3[4];                <span class="comment">/* 0x15C - 0x15F: Reserved */</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>    __RW uint32_t BURSTSIZE;                   <span class="comment">/* 0x160: Programmable Burst Size Register */</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span>    __RW uint32_t TXFILLTUNING;                <span class="comment">/* 0x164: TX FIFO Fill Tuning Register */</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span>    __R  uint8_t  RESERVED4[16];               <span class="comment">/* 0x168 - 0x177: Reserved */</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span>    __RW uint32_t ENDPTNAK;                    <span class="comment">/* 0x178: Endpoint NAK Register */</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>    __RW uint32_t ENDPTNAKEN;                  <span class="comment">/* 0x17C: Endpoint NAK Enable Register */</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>    __R  uint8_t  RESERVED5[4];                <span class="comment">/* 0x180 - 0x183: Reserved */</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>    __RW uint32_t PORTSC1;                     <span class="comment">/* 0x184: Port Status &amp; Control */</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>    __R  uint8_t  RESERVED6[28];               <span class="comment">/* 0x188 - 0x1A3: Reserved */</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>    __RW uint32_t OTGSC;                       <span class="comment">/* 0x1A4: On-The-Go Status &amp; control Register */</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span>    __RW uint32_t USBMODE;                     <span class="comment">/* 0x1A8: USB Device Mode Register */</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>    __RW uint32_t ENDPTSETUPSTAT;              <span class="comment">/* 0x1AC: Endpoint Setup Status Register */</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span>    __RW uint32_t ENDPTPRIME;                  <span class="comment">/* 0x1B0: Endpoint Prime Register */</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>    __RW uint32_t ENDPTFLUSH;                  <span class="comment">/* 0x1B4: Endpoint Flush Register */</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>    __R  uint32_t ENDPTSTAT;                   <span class="comment">/* 0x1B8: Endpoint Status Register */</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>    __RW uint32_t ENDPTCOMPLETE;               <span class="comment">/* 0x1BC: Endpoint Complete Register */</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>    __RW uint32_t ENDPTCTRL[16];               <span class="comment">/* 0x1C0 - 0x1FC: Endpoint Control0 Register... Endpoint Control7 Register */</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>    __RW uint32_t OTG_CTRL0;                   <span class="comment">/* 0x200:  */</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>    __R  uint8_t  RESERVED7[12];               <span class="comment">/* 0x204 - 0x20F: Reserved */</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>    __RW uint32_t PHY_CTRL0;                   <span class="comment">/* 0x210:  */</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>    __RW uint32_t PHY_CTRL1;                   <span class="comment">/* 0x214:  */</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>    __R  uint8_t  RESERVED8[8];                <span class="comment">/* 0x218 - 0x21F: Reserved */</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>    __RW uint32_t TOP_STATUS;                  <span class="comment">/* 0x220:  */</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>    __RW uint32_t PHY_STATUS;                  <span class="comment">/* 0x224:  */</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span>} <a class="code hl_struct" href="structUSB__Type.html">USB_Type</a>;</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span> </div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span> </div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment">/* Bitfield definition for register: GPTIMER0LD */</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment">/*</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment"> * GPTLD (RW)</span></div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment"> *</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment"> * GPTLD</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment"> * General Purpose Timer Load Value</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment"> * These bit fields are loaded to GPTCNT bits when GPTRST bit is set &#39;1b&#39;.</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span><span class="comment"> * This value represents the time in microseconds minus 1 for the timer duration.</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment"> * Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment"> * NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment"> */</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7b6ca0e761007b83f56782270c218245">   71</a></span><span class="preprocessor">#define USB_GPTIMER0LD_GPTLD_MASK (0xFFFFFFUL)</span></div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6ec21c8433109ed4ab32ca443e97f9d4">   72</a></span><span class="preprocessor">#define USB_GPTIMER0LD_GPTLD_SHIFT (0U)</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a01f0d90b6430a3b81afbf8ab6d0ef722">   73</a></span><span class="preprocessor">#define USB_GPTIMER0LD_GPTLD_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER0LD_GPTLD_SHIFT) &amp; USB_GPTIMER0LD_GPTLD_MASK)</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2c3774defc3d41918e1f5d5a1b236b7b">   74</a></span><span class="preprocessor">#define USB_GPTIMER0LD_GPTLD_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER0LD_GPTLD_MASK) &gt;&gt; USB_GPTIMER0LD_GPTLD_SHIFT)</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span> </div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="comment">/* Bitfield definition for register: GPTIMER0CTRL */</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="comment">/*</span></div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span><span class="comment"> * GPTRUN (RW)</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment"> *</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment"> * GPTRUN</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment"> * General Purpose Timer Run</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment"> * GPTCNT bits are not effected when setting or clearing this bit.</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment"> * 0 - Stop counting</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="comment"> * 1 - Run</span></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment"> */</span></div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac1ac9a8584527ddc229909104c953c21">   86</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRUN_MASK (0x80000000UL)</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa7b0dd114f2c1580c6b27b28b442e290">   87</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRUN_SHIFT (31U)</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3390c17f19cffa07415f68ddaaaa9ce5">   88</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRUN_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER0CTRL_GPTRUN_SHIFT) &amp; USB_GPTIMER0CTRL_GPTRUN_MASK)</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a10a6170895eabe42a568ef8b800cc7ac">   89</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRUN_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER0CTRL_GPTRUN_MASK) &gt;&gt; USB_GPTIMER0CTRL_GPTRUN_SHIFT)</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span> </div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment">/*</span></div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment"> * GPTRST (WO)</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment"> *</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment"> * GPTRST</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment"> * General Purpose Timer Reset</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment"> * 0 - No action</span></div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment"> * 1 - Load counter value from GPTLD bits in n_GPTIMER0LD</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment"> */</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a403171504e35daccc07f694df4184b20">   99</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRST_MASK (0x40000000UL)</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af211ecaf9a4d076835f04c59b63e3bdb">  100</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRST_SHIFT (30U)</span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad4fc90ec6d900dfb192eafe56c0044bc">  101</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRST_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER0CTRL_GPTRST_SHIFT) &amp; USB_GPTIMER0CTRL_GPTRST_MASK)</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1697584227bb888046d8d1b63b88a4df">  102</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTRST_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER0CTRL_GPTRST_MASK) &gt;&gt; USB_GPTIMER0CTRL_GPTRST_SHIFT)</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span> </div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment">/*</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment"> * GPTMODE (RW)</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment"> *</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment"> * GPTMODE</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment"> * General Purpose Timer Mode</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment"> * In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment"> * reset by software;</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment"> * In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment"> * counter value from GPTLD bits to start again.</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment"> * 0 - One Shot Mode</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment"> * 1 - Repeat Mode</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment"> */</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aac50dfb4392d260f7ef929409ed7ac43">  116</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTMODE_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a910f14094b6ed7bf493018301805e2e6">  117</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTMODE_SHIFT (24U)</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c0d00d114abedddac045fbb9ead1018">  118</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTMODE_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER0CTRL_GPTMODE_SHIFT) &amp; USB_GPTIMER0CTRL_GPTMODE_MASK)</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1644e718ee5161da5ca92949b98c03fa">  119</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTMODE_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER0CTRL_GPTMODE_MASK) &gt;&gt; USB_GPTIMER0CTRL_GPTMODE_SHIFT)</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span> </div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment">/*</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment"> * GPTCNT (RO)</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment"> *</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment"> * GPTCNT</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment"> * General Purpose Timer Counter.</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment"> * This field is the count value of the countdown timer.</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment"> */</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab5a29575a414e0ab208486cb6136927b">  128</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTCNT_MASK (0xFFFFFFUL)</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a52155f7e48ac6c0faa852f8833d34ebc">  129</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTCNT_SHIFT (0U)</span></div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac420e9d0319175763aef4b29d3104ccf">  130</a></span><span class="preprocessor">#define USB_GPTIMER0CTRL_GPTCNT_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER0CTRL_GPTCNT_MASK) &gt;&gt; USB_GPTIMER0CTRL_GPTCNT_SHIFT)</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span> </div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="comment">/* Bitfield definition for register: GPTIMER1LD */</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment">/*</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment"> * GPTLD (RW)</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment"> *</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment"> * GPTLD</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment"> * General Purpose Timer Load Value</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment"> * These bit fields are loaded to GPTCNT bits when GPTRST bit is set &#39;1b&#39;.</span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment"> * This value represents the time in microseconds minus 1 for the timer duration.</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment"> * Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment"> * NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment"> */</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aebb5d1b0ec67fda6c685401dccfa0c75">  143</a></span><span class="preprocessor">#define USB_GPTIMER1LD_GPTLD_MASK (0xFFFFFFUL)</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5ab336bcffeb8dc03664d02b8fb9e970">  144</a></span><span class="preprocessor">#define USB_GPTIMER1LD_GPTLD_SHIFT (0U)</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af118f063a7178a9483edfe3c4e940497">  145</a></span><span class="preprocessor">#define USB_GPTIMER1LD_GPTLD_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER1LD_GPTLD_SHIFT) &amp; USB_GPTIMER1LD_GPTLD_MASK)</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aefa3547b9b2681870922fe278500f871">  146</a></span><span class="preprocessor">#define USB_GPTIMER1LD_GPTLD_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER1LD_GPTLD_MASK) &gt;&gt; USB_GPTIMER1LD_GPTLD_SHIFT)</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span> </div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment">/* Bitfield definition for register: GPTIMER1CTRL */</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment">/*</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="comment"> * GPTRUN (RW)</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="comment"> *</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span><span class="comment"> * GPTRUN</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="comment"> * General Purpose Timer Run</span></div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="comment"> * GPTCNT bits are not effected when setting or clearing this bit.</span></div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span><span class="comment"> * 0 - Stop counting</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="comment"> * 1 - Run</span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span><span class="comment"> */</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a190ba3c090d9c1eda6a933ac099dd24e">  158</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRUN_MASK (0x80000000UL)</span></div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afc26bec10a78cee015a6f7aa831a01ad">  159</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRUN_SHIFT (31U)</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abde3b94ef1492a83c2d422bbeb7a2736">  160</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRUN_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER1CTRL_GPTRUN_SHIFT) &amp; USB_GPTIMER1CTRL_GPTRUN_MASK)</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5535cba426fb54df38b46c1e3729b210">  161</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRUN_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER1CTRL_GPTRUN_MASK) &gt;&gt; USB_GPTIMER1CTRL_GPTRUN_SHIFT)</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span> </div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment">/*</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment"> * GPTRST (WO)</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment"> *</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment"> * GPTRST</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment"> * General Purpose Timer Reset</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment"> * 0 - No action</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment"> * 1 - Load counter value from GPTLD bits in USB_n_GPTIMER1LD</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="comment"> */</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acd8a6e821adaa5036a47a5dbc457379f">  171</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRST_MASK (0x40000000UL)</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa1260811615df9e050afc9cb080248f8">  172</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRST_SHIFT (30U)</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a67f7cf05f2a5a3ab7577a4c394e0e464">  173</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRST_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER1CTRL_GPTRST_SHIFT) &amp; USB_GPTIMER1CTRL_GPTRST_MASK)</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a33dd93c213c72900edbaddfb2a27c80e">  174</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTRST_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER1CTRL_GPTRST_MASK) &gt;&gt; USB_GPTIMER1CTRL_GPTRST_SHIFT)</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span> </div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">/*</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment"> * GPTMODE (RW)</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment"> *</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment"> * GPTMODE</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment"> * General Purpose Timer Mode</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="comment"> * In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="comment"> * reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span><span class="comment"> * automatically reload the counter value from GPTLD bits to start again.</span></div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="comment"> * 0 - One Shot Mode</span></div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment"> * 1 - Repeat Mode</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="comment"> */</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa30b489e0dd5c456bd868a58b19fa302">  187</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTMODE_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a82abbdb958f5b96c88339750c130f1c1">  188</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTMODE_SHIFT (24U)</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4aec6564e4f037c1425ece287b5c7fc1">  189</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTMODE_SET(x) (((uint32_t)(x) &lt;&lt; USB_GPTIMER1CTRL_GPTMODE_SHIFT) &amp; USB_GPTIMER1CTRL_GPTMODE_MASK)</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2a38022fc560b955b6f05715c5168419">  190</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTMODE_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER1CTRL_GPTMODE_MASK) &gt;&gt; USB_GPTIMER1CTRL_GPTMODE_SHIFT)</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span> </div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="comment">/*</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="comment"> * GPTCNT (RO)</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span><span class="comment"> *</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment"> * GPTCNT</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span><span class="comment"> * General Purpose Timer Counter.</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment"> * This field is the count value of the countdown timer.</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="comment"> */</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7e8b4fd5a9211236771e644205487868">  199</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTCNT_MASK (0xFFFFFFUL)</span></div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa52cec188f9983d5b5ee4e57f87bf2b0">  200</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTCNT_SHIFT (0U)</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a33e53cf364f49248440a4540792c3471">  201</a></span><span class="preprocessor">#define USB_GPTIMER1CTRL_GPTCNT_GET(x) (((uint32_t)(x) &amp; USB_GPTIMER1CTRL_GPTCNT_MASK) &gt;&gt; USB_GPTIMER1CTRL_GPTCNT_SHIFT)</span></div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span> </div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="comment">/* Bitfield definition for register: SBUSCFG */</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment">/*</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="comment"> * AHBBRST (RW)</span></div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span><span class="comment"> *</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="comment"> * AHBBRST</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment"> * AHB master interface Burst configuration</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span><span class="comment"> * These bits control AHB master transfer type sequence (or priority).</span></div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span><span class="comment"> * NOTE: This register overrides n_BURSTSIZE register when its value is not zero.</span></div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment"> * 000 - Incremental burst of unspecified length only</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="comment"> * 001 - INCR4 burst, then single transfer</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span><span class="comment"> * 010 - INCR8 burst, INCR4 burst, then single transfer</span></div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="comment"> * 011 - INCR16 burst, INCR8 burst, INCR4 burst, then single transfer</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span><span class="comment"> * 100 - Reserved, don&#39;t use</span></div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span><span class="comment"> * 101 - INCR4 burst, then incremental burst of unspecified length</span></div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span><span class="comment"> * 110 - INCR8 burst, INCR4 burst, then incremental burst of unspecified length</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span><span class="comment"> * 111 - INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length</span></div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment"> */</span></div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aea05262b8891135149a753b0df4763b5">  220</a></span><span class="preprocessor">#define USB_SBUSCFG_AHBBRST_MASK (0x7U)</span></div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af6977bd2e716815ff20ae0590454d3c6">  221</a></span><span class="preprocessor">#define USB_SBUSCFG_AHBBRST_SHIFT (0U)</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac3f6366b49b76a7cfaa3f0d150b5304d">  222</a></span><span class="preprocessor">#define USB_SBUSCFG_AHBBRST_SET(x) (((uint32_t)(x) &lt;&lt; USB_SBUSCFG_AHBBRST_SHIFT) &amp; USB_SBUSCFG_AHBBRST_MASK)</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afa12f17bf9d20b34e4b7e690b8171d60">  223</a></span><span class="preprocessor">#define USB_SBUSCFG_AHBBRST_GET(x) (((uint32_t)(x) &amp; USB_SBUSCFG_AHBBRST_MASK) &gt;&gt; USB_SBUSCFG_AHBBRST_SHIFT)</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span> </div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment">/* Bitfield definition for register: USBCMD */</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="comment">/*</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment"> * ITC (RW)</span></div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment"> *</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment"> * ITC</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment"> * Interrupt Threshold Control -Read/Write.</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment"> * The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment"> * ITC contains the maximum interrupt interval measured in micro-frames. Valid values are</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="comment"> * shown below.</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span><span class="comment"> * Value Maximum Interrupt Interval</span></div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span><span class="comment"> * 00000000 - Immediate (no threshold)</span></div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span><span class="comment"> * 00000001 - 1 micro-frame</span></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span><span class="comment"> * 00000010 - 2 micro-frames</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span><span class="comment"> * 00000100 - 4 micro-frames</span></div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span><span class="comment"> * 00001000 - 8 micro-frames</span></div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span><span class="comment"> * 00010000 - 16 micro-frames</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="comment"> * 00100000 - 32 micro-frames</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span><span class="comment"> * 01000000 - 64 micro-frames</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="comment"> */</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c29341dc4dcdde69df53df860d1eb52">  244</a></span><span class="preprocessor">#define USB_USBCMD_ITC_MASK (0xFF0000UL)</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a11446e248248655aebbc42d3754b5aa9">  245</a></span><span class="preprocessor">#define USB_USBCMD_ITC_SHIFT (16U)</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a35258d0dbe3d406536c83119979cbbd1">  246</a></span><span class="preprocessor">#define USB_USBCMD_ITC_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_ITC_SHIFT) &amp; USB_USBCMD_ITC_MASK)</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0f83dc7e54df1e6f35e9616effee80f5">  247</a></span><span class="preprocessor">#define USB_USBCMD_ITC_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_ITC_MASK) &gt;&gt; USB_USBCMD_ITC_SHIFT)</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span> </div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment">/*</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment"> * FS_2 (RW)</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="comment"> *</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span><span class="comment"> * FS_2</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span><span class="comment"> * Frame List Size - (Read/Write or Read Only). [host mode only]</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span><span class="comment"> * This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span><span class="comment"> * This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span><span class="comment"> * NOTE: This field is made up from USBCMD bits 15, 3 and 2.</span></div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span><span class="comment"> * Value Meaning</span></div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="comment"> * 0b000 - 1024 elements (4096 bytes) Default value</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span><span class="comment"> * 0b001 - 512 elements (2048 bytes)</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span><span class="comment"> * 0b010 - 256 elements (1024 bytes)</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment"> * 0b011 - 128 elements (512 bytes)</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="comment"> * 0b100 - 64 elements (256 bytes)</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment"> * 0b101 - 32 elements (128 bytes)</span></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment"> * 0b110 - 16 elements (64 bytes)</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment"> * 0b111 - 8 elements (32 bytes)</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span><span class="comment"> */</span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a124c7b05e80b655f7664b26a9d6b1be5">  267</a></span><span class="preprocessor">#define USB_USBCMD_FS_2_MASK (0x8000U)</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a65faee3cc00efb7044a783f383d76b21">  268</a></span><span class="preprocessor">#define USB_USBCMD_FS_2_SHIFT (15U)</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae6e841d7d14c3da725e8cac430b2b4fd">  269</a></span><span class="preprocessor">#define USB_USBCMD_FS_2_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_FS_2_SHIFT) &amp; USB_USBCMD_FS_2_MASK)</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1ae32fb5150b01c334d186db1df6f97b">  270</a></span><span class="preprocessor">#define USB_USBCMD_FS_2_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_FS_2_MASK) &gt;&gt; USB_USBCMD_FS_2_SHIFT)</span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span> </div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment">/*</span></div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment"> * ATDTW (RW)</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span><span class="comment"> *</span></div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment"> * ATDTW</span></div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment"> * Add dTD TripWire - Read/Write. [device mode only]</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment"> * This bit is used as a semaphore to ensure proper addition of a new dTD to an active (primed) endpoint&#39;s</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment"> * linked list. This bit is set and cleared by software.</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment"> * This bit would also be cleared by hardware when state machine is hazard region for which adding a dTD</span></div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment"> * to a primed endpoint may go unrecognized.</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment"> */</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a783591d8158eade46e3da21ac82a98b0">  282</a></span><span class="preprocessor">#define USB_USBCMD_ATDTW_MASK (0x4000U)</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a898d64d57eb621819e926548c1a86cd1">  283</a></span><span class="preprocessor">#define USB_USBCMD_ATDTW_SHIFT (14U)</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0ac890befa8dd7583a790e424a09461a">  284</a></span><span class="preprocessor">#define USB_USBCMD_ATDTW_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_ATDTW_SHIFT) &amp; USB_USBCMD_ATDTW_MASK)</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a60dc0b03fab69526518ce77907e0ccdb">  285</a></span><span class="preprocessor">#define USB_USBCMD_ATDTW_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_ATDTW_MASK) &gt;&gt; USB_USBCMD_ATDTW_SHIFT)</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span> </div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment">/*</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="comment"> * SUTW (RW)</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment"> *</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment"> * SUTW</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment"> * Setup TripWire - Read/Write. [device mode only]</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="comment"> * This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is extracted from a QH by the DCD without being corrupted.</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"> * If the setup lockout mode is off (SLOM bit in USB core register n_USBMODE, see USBMODE ) then</span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment"> * there is a hazard when new setup data arrives while the DCD is copying the setup data payload</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="comment"> * from the QH for a previous setup packet. This bit is set and cleared by software.</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment"> * This bit would also be cleared by hardware when a hazard detected.</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment"> */</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad47846d043be0b70aefcff1f98d0c6ba">  298</a></span><span class="preprocessor">#define USB_USBCMD_SUTW_MASK (0x2000U)</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8143190db86389218d3b2641ed6b02ba">  299</a></span><span class="preprocessor">#define USB_USBCMD_SUTW_SHIFT (13U)</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af15a6ea665051bb9ae7987387304275d">  300</a></span><span class="preprocessor">#define USB_USBCMD_SUTW_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_SUTW_SHIFT) &amp; USB_USBCMD_SUTW_MASK)</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae5bb817e6439373619fa5c2abda8d88f">  301</a></span><span class="preprocessor">#define USB_USBCMD_SUTW_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_SUTW_MASK) &gt;&gt; USB_USBCMD_SUTW_SHIFT)</span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span> </div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment">/*</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment"> * PRM (WO)</span></div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span><span class="comment"> *</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment"> * Asynchronous Schedule start- Write only， host mode only。</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="comment"> * this bit is used to notify hostcontroller to start async schedule immediately.</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span><span class="comment"> */</span></div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2cdfb0781592629207ebb4b591c4d058">  309</a></span><span class="preprocessor">#define USB_USBCMD_PRM_MASK (0x1000U)</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afca190620ce3d4b223a78e16b773285f">  310</a></span><span class="preprocessor">#define USB_USBCMD_PRM_SHIFT (12U)</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6438ccb1fea75257e47e6278538bcf19">  311</a></span><span class="preprocessor">#define USB_USBCMD_PRM_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_PRM_SHIFT) &amp; USB_USBCMD_PRM_MASK)</span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a91273ae9ac469a0ad058a9cd9848a6d8">  312</a></span><span class="preprocessor">#define USB_USBCMD_PRM_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_PRM_MASK) &gt;&gt; USB_USBCMD_PRM_SHIFT)</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span> </div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment">/*</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment"> * ASPE (RW)</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment"> *</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment"> * ASPE</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment"> * Asynchronous Schedule Park Mode Enable - Read/Write.</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment"> * If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1h and is R/W.</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="comment"> * Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode.</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span><span class="comment"> * When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.</span></div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment"> * NOTE: ASPE bit reset value: &#39;0b&#39; for OTG controller .</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="comment"> */</span></div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1d419739951a9e9499bbfba25f56a922">  324</a></span><span class="preprocessor">#define USB_USBCMD_ASPE_MASK (0x800U)</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abe92acb97560b249097d98a584864c8a">  325</a></span><span class="preprocessor">#define USB_USBCMD_ASPE_SHIFT (11U)</span></div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2dbf0114805d85723315c89983d541df">  326</a></span><span class="preprocessor">#define USB_USBCMD_ASPE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_ASPE_SHIFT) &amp; USB_USBCMD_ASPE_MASK)</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a808c7422348b8b38358e1b4a21985109">  327</a></span><span class="preprocessor">#define USB_USBCMD_ASPE_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_ASPE_MASK) &gt;&gt; USB_USBCMD_ASPE_SHIFT)</span></div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span> </div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment">/*</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="comment"> * ASP (RW)</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span><span class="comment"> *</span></div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span><span class="comment"> * ASP</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment"> * Asynchronous Schedule Park Mode Count - Read/Write.</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="comment"> * If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is Read-Only.</span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment"> * It contains a count of the number of successive transactions the host controller is allowed to</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment"> * execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule.</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span><span class="comment"> * Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enable is a one as this will result in undefined behavior.</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span><span class="comment"> * This field is set to 3h in all controller core.</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment"> */</span></div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aafd231588b836dc35a7d41ba5a719ac8">  340</a></span><span class="preprocessor">#define USB_USBCMD_ASP_MASK (0x300U)</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a404732527586b9f0de3ec331e2d136ad">  341</a></span><span class="preprocessor">#define USB_USBCMD_ASP_SHIFT (8U)</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac92cc0bb197924c2ed5bc3641d17f8e9">  342</a></span><span class="preprocessor">#define USB_USBCMD_ASP_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_ASP_SHIFT) &amp; USB_USBCMD_ASP_MASK)</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abf6f72044091d83ee6b03326876cb445">  343</a></span><span class="preprocessor">#define USB_USBCMD_ASP_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_ASP_MASK) &gt;&gt; USB_USBCMD_ASP_SHIFT)</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span> </div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment">/*</span></div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span><span class="comment"> * IAA (RW)</span></div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment"> *</span></div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment"> * IAA</span></div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span><span class="comment"> * Interrupt on Async Advance Doorbell - Read/Write.</span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment"> * This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ring the doorbell.</span></div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment"> * When the host controller has evicted all appropriate cached schedule states,</span></div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span><span class="comment"> * it sets the Interrupt on Async Advance status bit in the USBSTS register.</span></div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment"> * If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold.</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment"> * The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span><span class="comment"> * Software should not write a one to this bit when the asynchronous  schedule is inactive. Doing so will yield undefined results.</span></div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="comment"> * This bit is only used in host mode. Writing a one to this bit when device mode is selected will have undefined results.</span></div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span><span class="comment"> */</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a24d342c76e3ae3a938839a954c85b93c">  358</a></span><span class="preprocessor">#define USB_USBCMD_IAA_MASK (0x40U)</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab5a136f69bd6eefe0ad12d50ca1b0a2d">  359</a></span><span class="preprocessor">#define USB_USBCMD_IAA_SHIFT (6U)</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7f92dbb5d573b0c54a3eb10b2f07194a">  360</a></span><span class="preprocessor">#define USB_USBCMD_IAA_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_IAA_SHIFT) &amp; USB_USBCMD_IAA_MASK)</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a25ff4987eaea221cc19add3407c8f05e">  361</a></span><span class="preprocessor">#define USB_USBCMD_IAA_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_IAA_MASK) &gt;&gt; USB_USBCMD_IAA_SHIFT)</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span> </div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment">/*</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment"> * ASE (RW)</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment"> *</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment"> * ASE</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span><span class="comment"> * Asynchronous Schedule Enable - Read/Write. Default 0b.</span></div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment"> * This bit controls whether the host controller skips processing the Asynchronous Schedule.</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment"> * Only the host controller uses this bit.</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="comment"> * Values Meaning</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment"> * 0 - Do not process the Asynchronous Schedule.</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment"> * 1 - Use the ASYNCLISTADDR register to access the Asynchronous Schedule.</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span><span class="comment"> */</span></div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adb1cc197c8525f74838bcb5593318c14">  374</a></span><span class="preprocessor">#define USB_USBCMD_ASE_MASK (0x20U)</span></div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9bcf8c36d7f6e2c196f15cc5f658956e">  375</a></span><span class="preprocessor">#define USB_USBCMD_ASE_SHIFT (5U)</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af6ef59c5622857df0391d938f78cda84">  376</a></span><span class="preprocessor">#define USB_USBCMD_ASE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_ASE_SHIFT) &amp; USB_USBCMD_ASE_MASK)</span></div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5e69f622e3d30b861c4bf2734b29e69f">  377</a></span><span class="preprocessor">#define USB_USBCMD_ASE_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_ASE_MASK) &gt;&gt; USB_USBCMD_ASE_SHIFT)</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span> </div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment">/*</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment"> * PSE (RW)</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment"> *</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment"> * PSE</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment"> * Periodic Schedule Enable- Read/Write. Default 0b.</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment"> * This bit controls whether the host controller skips processing the Periodic Schedule.</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment"> * Only the host controller uses this bit.</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment"> * Values Meaning</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment"> * 0 - Do not process the Periodic Schedule</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment"> * 1 - Use the PERIODICLISTBASE register to access the Periodic Schedule.</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment"> */</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a914fe00fde56b7e369f0f5a2bee976fe">  390</a></span><span class="preprocessor">#define USB_USBCMD_PSE_MASK (0x10U)</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0ead472bf24645bb353829d18186b77a">  391</a></span><span class="preprocessor">#define USB_USBCMD_PSE_SHIFT (4U)</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2b81bc1dd373f1a33738761392b70c07">  392</a></span><span class="preprocessor">#define USB_USBCMD_PSE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_PSE_SHIFT) &amp; USB_USBCMD_PSE_MASK)</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afbc1768b34f9ddd81261f590e9bd9e92">  393</a></span><span class="preprocessor">#define USB_USBCMD_PSE_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_PSE_MASK) &gt;&gt; USB_USBCMD_PSE_SHIFT)</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span> </div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment">/*</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment"> * FS_1 (RW)</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment"> *</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment"> * FS_1</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment"> * See description at bit 15</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment"> */</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac1629a4023b152a3c9d65a0b413873d4">  401</a></span><span class="preprocessor">#define USB_USBCMD_FS_1_MASK (0xCU)</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7a21761b254027e320b5b5d433329cbb">  402</a></span><span class="preprocessor">#define USB_USBCMD_FS_1_SHIFT (2U)</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2404e934a77a5f0778957365a35e549d">  403</a></span><span class="preprocessor">#define USB_USBCMD_FS_1_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_FS_1_SHIFT) &amp; USB_USBCMD_FS_1_MASK)</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2d26deaa41ac489c5e9e3a890f7f4ad9">  404</a></span><span class="preprocessor">#define USB_USBCMD_FS_1_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_FS_1_MASK) &gt;&gt; USB_USBCMD_FS_1_SHIFT)</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span> </div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment">/*</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment"> * RST (RW)</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment"> *</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment"> * RST</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment"> * Controller Reset (RESET) - Read/Write. Software uses this bit to reset the controller.</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment"> * This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment"> * Host operation mode:</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment"> * When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment"> * Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment"> * Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment"> * Attempting to reset an actively running host controller will result in undefined behavior.</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="comment"> * Device operation mode:</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="comment"> * When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.</span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="comment"> * Writing a one to this bit when the device is in the attached state is not recommended, because the effect on an attached host is undefined.</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="comment"> * In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="comment"> */</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a12b1dda8788532fbb297121698a3f207">  422</a></span><span class="preprocessor">#define USB_USBCMD_RST_MASK (0x2U)</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3b5e0f29616e22632bdecf834e5a8791">  423</a></span><span class="preprocessor">#define USB_USBCMD_RST_SHIFT (1U)</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af3309df08d9f353c0ef98b16e14cb68e">  424</a></span><span class="preprocessor">#define USB_USBCMD_RST_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_RST_SHIFT) &amp; USB_USBCMD_RST_MASK)</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0069e021ae5c6f18b38d1cd61c03f796">  425</a></span><span class="preprocessor">#define USB_USBCMD_RST_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_RST_MASK) &gt;&gt; USB_USBCMD_RST_SHIFT)</span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span> </div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="comment">/*</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="comment"> * RS (RW)</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="comment"> *</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span><span class="comment"> * RS</span></div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment"> * Run/Stop (RS) - Read/Write. Default 0b. 1=Run. 0=Stop.</span></div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment"> * Host operation mode:</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="comment"> * When set to &#39;1b&#39;, the Controller proceeds with the execution of the schedule. The Controller continues execution as long as this bit is set to a one.</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="comment"> * When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment"> * The HC Halted bit in the status register indicates when the Controller has finished the transaction and has entered the stopped state.</span></div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment"> * Software should not write a one to this field unless the controller is in the Halted state (that is, HCHalted in the USBSTS register is a one).</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment"> * Device operation mode:</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment"> * Writing a one to this bit will cause the controller to enable a pull-up on D+ and initiate an attach event.</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="comment"> * This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode.</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="comment"> * Software should use this bit to prevent an attach event before the controller has been properly initialized. Writing a 0 to this will cause a detach event.</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="comment"> */</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c8627cff2022a9a1ec79adb60196a59">  442</a></span><span class="preprocessor">#define USB_USBCMD_RS_MASK (0x1U)</span></div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afa0505aa25a3e21ccf850ef808c8d99f">  443</a></span><span class="preprocessor">#define USB_USBCMD_RS_SHIFT (0U)</span></div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab0bb4c4afc2322f8ed4541d2882cabb1">  444</a></span><span class="preprocessor">#define USB_USBCMD_RS_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBCMD_RS_SHIFT) &amp; USB_USBCMD_RS_MASK)</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9587d83e5816403b42996946332eab16">  445</a></span><span class="preprocessor">#define USB_USBCMD_RS_GET(x) (((uint32_t)(x) &amp; USB_USBCMD_RS_MASK) &gt;&gt; USB_USBCMD_RS_SHIFT)</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span> </div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment">/* Bitfield definition for register: USBSTS */</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment">/*</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment"> * TI1 (RWC)</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment"> *</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment"> * TI1</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment"> * General Purpose Timer Interrupt 1(GPTINT1)--R/WC.</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment"> * This bit is set when the counter in the GPTIMER1CTRL register transitions to zero, writing a one to this</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment"> * bit will clear it.</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span><span class="comment"> */</span></div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aded7e7a2d12cd51f677ebb39d2fd7fc1">  456</a></span><span class="preprocessor">#define USB_USBSTS_TI1_MASK (0x2000000UL)</span></div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a484685489fef38a448f42fd5d9e6b880">  457</a></span><span class="preprocessor">#define USB_USBSTS_TI1_SHIFT (25U)</span></div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acc1cf94c4ae37b6e20423bdeb65a227d">  458</a></span><span class="preprocessor">#define USB_USBSTS_TI1_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_TI1_SHIFT) &amp; USB_USBSTS_TI1_MASK)</span></div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1272a42607829dc9431601483b0518dd">  459</a></span><span class="preprocessor">#define USB_USBSTS_TI1_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_TI1_MASK) &gt;&gt; USB_USBSTS_TI1_SHIFT)</span></div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span> </div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="comment">/*</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment"> * TI0 (RWC)</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment"> *</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment"> * TI0</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="comment"> * General Purpose Timer Interrupt 0(GPTINT0)--R/WC.</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment"> * This bit is set when the counter in the GPTIMER0CTRL register transitions to zero, writing a one to this</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment"> * bit clears it.</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment"> */</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a260b8b310d9e2f9b016f0d877c725159">  469</a></span><span class="preprocessor">#define USB_USBSTS_TI0_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac726a81454a65a71da29ebe6a06661ea">  470</a></span><span class="preprocessor">#define USB_USBSTS_TI0_SHIFT (24U)</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a976af599d2e948fd285444b7a9f36d94">  471</a></span><span class="preprocessor">#define USB_USBSTS_TI0_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_TI0_SHIFT) &amp; USB_USBSTS_TI0_MASK)</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#add8bf6ce61befd1f8200c88f44d5cfbd">  472</a></span><span class="preprocessor">#define USB_USBSTS_TI0_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_TI0_MASK) &gt;&gt; USB_USBSTS_TI0_SHIFT)</span></div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span> </div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span><span class="comment">/*</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="comment"> * UPI (RWC)</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment"> *</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment"> * USB Host Periodic Interrupt – RWC. Default = 0b.</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="comment"> * This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction</span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment"> * where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment"> * This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule.</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment"> * A short packet is when the actual number of bytes received was less than expected.</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment"> * This bit is not used by the device controller and will always be zero.</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment"> */</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8b62b0c336279138d4fe867cb87a1e9f">  484</a></span><span class="preprocessor">#define USB_USBSTS_UPI_MASK (0x80000UL)</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a89f60e619384fbcdd4470f80812da5d5">  485</a></span><span class="preprocessor">#define USB_USBSTS_UPI_SHIFT (19U)</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa35f861de395b5a6bfd74817a0bce813">  486</a></span><span class="preprocessor">#define USB_USBSTS_UPI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_UPI_SHIFT) &amp; USB_USBSTS_UPI_MASK)</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a58e1425253382dcb07202c60a5e6cfe4">  487</a></span><span class="preprocessor">#define USB_USBSTS_UPI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_UPI_MASK) &gt;&gt; USB_USBSTS_UPI_SHIFT)</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span> </div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment">/*</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="comment"> * UAI (RWC)</span></div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="comment"> *</span></div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="comment"> * USB Host Asynchronous Interrupt – RWC. Default = 0b.</span></div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment"> * This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment"> * where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment"> * This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule.</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span><span class="comment"> * A short packet is when the actual number of bytes received was less than expected.</span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment"> * This bit is not used by the device controller and will always be zero</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment"> */</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a978db7e46a189b9213024ef9e93c36a5">  499</a></span><span class="preprocessor">#define USB_USBSTS_UAI_MASK (0x40000UL)</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af4c01139736b88e5320febfc70695328">  500</a></span><span class="preprocessor">#define USB_USBSTS_UAI_SHIFT (18U)</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a06144b4dd35574fc065b02fa18ad9a2c">  501</a></span><span class="preprocessor">#define USB_USBSTS_UAI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_UAI_SHIFT) &amp; USB_USBSTS_UAI_MASK)</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6af89787efb744f6d206ea5876eaffb3">  502</a></span><span class="preprocessor">#define USB_USBSTS_UAI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_UAI_MASK) &gt;&gt; USB_USBSTS_UAI_SHIFT)</span></div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span> </div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment">/*</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="comment"> * NAKI (RO)</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment"> *</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment"> * NAKI</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment"> * NAK Interrupt Bit--RO.</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment"> * This bit is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment"> * corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware</span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment"> * when all Enabled TX/RX Endpoint NAK bits are cleared.</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment"> */</span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2eb4bc3a61d9fd441c86961c729a3cf6">  513</a></span><span class="preprocessor">#define USB_USBSTS_NAKI_MASK (0x10000UL)</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1a80b7bec79f92a2153feb5135db15c1">  514</a></span><span class="preprocessor">#define USB_USBSTS_NAKI_SHIFT (16U)</span></div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac79a1a5ae8285fa254ff5061691d5b00">  515</a></span><span class="preprocessor">#define USB_USBSTS_NAKI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_NAKI_MASK) &gt;&gt; USB_USBSTS_NAKI_SHIFT)</span></div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span> </div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="comment">/*</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="comment"> * AS (RO)</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="comment"> *</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment"> * AS</span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment"> * Asynchronous Schedule Status - Read Only.</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment"> * This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment"> * The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span><span class="comment"> * When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).</span></div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment"> * Only used in the host operation mode.</span></div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment"> */</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8e0f9998adb3608623cc97818752ebc0">  527</a></span><span class="preprocessor">#define USB_USBSTS_AS_MASK (0x8000U)</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a33f988955f7681e6167c790015fabb5d">  528</a></span><span class="preprocessor">#define USB_USBSTS_AS_SHIFT (15U)</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aada16e969743688638963358f36997a4">  529</a></span><span class="preprocessor">#define USB_USBSTS_AS_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_AS_MASK) &gt;&gt; USB_USBSTS_AS_SHIFT)</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span> </div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment">/*</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span><span class="comment"> * PS (RO)</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="comment"> *</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span><span class="comment"> * PS</span></div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="comment"> * Periodic Schedule Status - Read Only.</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span><span class="comment"> * This bit reports the current real status of the Periodic Schedule. When set to zero the periodic schedule is disabled, and if set to one the status is enabled.</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="comment"> * The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="comment"> * When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="comment"> * Only used in the host operation mode.</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="comment"> */</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa615d9fef2a5c45942d24c25855bde75">  541</a></span><span class="preprocessor">#define USB_USBSTS_PS_MASK (0x4000U)</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a06392a645fe7b8d30351057da3a2c828">  542</a></span><span class="preprocessor">#define USB_USBSTS_PS_SHIFT (14U)</span></div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7ef2fe1511499aabb2083c8cf4e49464">  543</a></span><span class="preprocessor">#define USB_USBSTS_PS_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_PS_MASK) &gt;&gt; USB_USBSTS_PS_SHIFT)</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span> </div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment">/*</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment"> * RCL (RO)</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="comment"> *</span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="comment"> * RCL</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="comment"> * Reclamation - Read Only.</span></div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="comment"> * This is a read-only status bit used to detect an empty asynchronous schedule.</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="comment"> * Only used in the host operation mode.</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="comment"> */</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aad06ed5a9927cb503897633d441e6ffb">  553</a></span><span class="preprocessor">#define USB_USBSTS_RCL_MASK (0x2000U)</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1df5c2a6fe22f4044dbf798639ac3d8b">  554</a></span><span class="preprocessor">#define USB_USBSTS_RCL_SHIFT (13U)</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4c9ebdced589e5f8d64693805a674496">  555</a></span><span class="preprocessor">#define USB_USBSTS_RCL_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_RCL_MASK) &gt;&gt; USB_USBSTS_RCL_SHIFT)</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span> </div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="comment">/*</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span><span class="comment"> * HCH (RO)</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment"> *</span></div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment"> * HCH</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment"> * HCHaIted - Read Only.</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span><span class="comment"> * This bit is a zero whenever the Run/Stop bit is a one.</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="comment"> *  The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0,</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span><span class="comment"> *  either by software or by the Controller hardware (for example, an internal error).</span></div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment"> * Only used in the host operation mode.</span></div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment"> * Default value is &#39;0b&#39; for OTG core .</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span><span class="comment"> * This is because OTG core is not operating as host in default. Please see CM bit in USB_n_USBMODE</span></div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment"> * register.</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment"> * NOTE: HCH bit reset value: &#39;0b&#39; for OTG controller core .</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="comment"> */</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aca6e6e4fa879507426f90a01de0abdfa">  571</a></span><span class="preprocessor">#define USB_USBSTS_HCH_MASK (0x1000U)</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a99311277fb86b3f29c328c009a244adb">  572</a></span><span class="preprocessor">#define USB_USBSTS_HCH_SHIFT (12U)</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a51484f6d8ca305af297d75cc8d06d947">  573</a></span><span class="preprocessor">#define USB_USBSTS_HCH_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_HCH_MASK) &gt;&gt; USB_USBSTS_HCH_SHIFT)</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span> </div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment">/*</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment"> * SLI (RWC)</span></div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment"> *</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment"> * SLI</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment"> * DCSuspend - R/WC.</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment"> * When a controller enters a suspend state from an active state, this bit will be set to a one. The device controller clears the bit upon exiting from a suspend state.</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment"> * Only used in device operation mode.</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment"> */</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab16373c80187c2d619ccca0577fc3160">  583</a></span><span class="preprocessor">#define USB_USBSTS_SLI_MASK (0x100U)</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa1ca92eb5b07e75e6ce13ee6b50bec13">  584</a></span><span class="preprocessor">#define USB_USBSTS_SLI_SHIFT (8U)</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a931cd4b8e00c2307f8a5a1988f155429">  585</a></span><span class="preprocessor">#define USB_USBSTS_SLI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_SLI_SHIFT) &amp; USB_USBSTS_SLI_MASK)</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a622a9c911633a32b1028b92a029b971d">  586</a></span><span class="preprocessor">#define USB_USBSTS_SLI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_SLI_MASK) &gt;&gt; USB_USBSTS_SLI_SHIFT)</span></div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span> </div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment">/*</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment"> * SRI (RWC)</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment"> *</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment"> * SRI</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment"> * SOF Received - R/WC.</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment"> * When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment"> * When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected.</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment"> * Therefore, this bit will be set roughly every 1ms in device FS mode and every 125ms in HS mode and will be synchronized to the actual SOF that is received.</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="comment"> * Because the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.</span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span><span class="comment"> * In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.</span></div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="comment"> * Software writes a 1 to this bit to clear it.</span></div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment"> */</span></div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0817afbb693f1a2a3137d1b6fa905808">  600</a></span><span class="preprocessor">#define USB_USBSTS_SRI_MASK (0x80U)</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6331d4ef5306407e84ac2c7e6888ffd3">  601</a></span><span class="preprocessor">#define USB_USBSTS_SRI_SHIFT (7U)</span></div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad419fde47016860d82764d91208b1b60">  602</a></span><span class="preprocessor">#define USB_USBSTS_SRI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_SRI_SHIFT) &amp; USB_USBSTS_SRI_MASK)</span></div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abb8b978419563acb4b1256f72e649521">  603</a></span><span class="preprocessor">#define USB_USBSTS_SRI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_SRI_MASK) &gt;&gt; USB_USBSTS_SRI_SHIFT)</span></div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span> </div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span><span class="comment">/*</span></div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span><span class="comment"> * URI (RWC)</span></div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment"> *</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment"> * URI</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span><span class="comment"> * USB Reset Received - R/WC.</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span><span class="comment"> * When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment"> * Software can write a 1 to this bit to clear the USB Reset Received status bit.</span></div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment"> * Only used in device operation mode.</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment"> */</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a81525ec9c6eff759a24e823ea13b76d7">  614</a></span><span class="preprocessor">#define USB_USBSTS_URI_MASK (0x40U)</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa2026829042a9bcb5f1bb28dd230dab5">  615</a></span><span class="preprocessor">#define USB_USBSTS_URI_SHIFT (6U)</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab253592c34ae077b6edebd7f80421658">  616</a></span><span class="preprocessor">#define USB_USBSTS_URI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_URI_SHIFT) &amp; USB_USBSTS_URI_MASK)</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1b9b1c23eb3c1825571e931495f3f203">  617</a></span><span class="preprocessor">#define USB_USBSTS_URI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_URI_MASK) &gt;&gt; USB_USBSTS_URI_SHIFT)</span></div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span> </div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span><span class="comment">/*</span></div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span><span class="comment"> * AAI (RWC)</span></div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span><span class="comment"> *</span></div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment"> * AAI</span></div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="comment"> * Interrupt on Async Advance - R/WC.</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="comment"> * System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span><span class="comment"> * by writing a one to the Interrupt on Async Advance Doorbell bit in the n_USBCMD register. This status bit indicates the assertion of that interrupt source.</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="comment"> * Only used in host operation mode.</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><span class="comment"> */</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a298d54ada6884792f73a2fc6f25af0b1">  628</a></span><span class="preprocessor">#define USB_USBSTS_AAI_MASK (0x20U)</span></div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a47600018f909c871205ca8a7dfdfde8c">  629</a></span><span class="preprocessor">#define USB_USBSTS_AAI_SHIFT (5U)</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a39aa5082323bb2cf5e4fb132a49d43d4">  630</a></span><span class="preprocessor">#define USB_USBSTS_AAI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_AAI_SHIFT) &amp; USB_USBSTS_AAI_MASK)</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ace75713bbc6e1edf5336ebbbd006e447">  631</a></span><span class="preprocessor">#define USB_USBSTS_AAI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_AAI_MASK) &gt;&gt; USB_USBSTS_AAI_SHIFT)</span></div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span> </div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment">/*</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment"> * SEI (RWC)</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="comment"> *</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="comment"> * System Error – RWC. Default = 0b.</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span><span class="comment"> * In the BVCI implementation of the USBHS core, this bit is not used, and will always be cleared to &#39;0b&#39;.</span></div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span><span class="comment"> * In the AMBA implementation, this bit will be set to &#39;1b&#39; when an Error response is seen by the master interface (HRESP[1:0]=ERROR)</span></div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span><span class="comment"> */</span></div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1882e5d110e0de7aa64699805a7cd6ea">  640</a></span><span class="preprocessor">#define USB_USBSTS_SEI_MASK (0x10U)</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af007b5e40bb709786028be06424b5ade">  641</a></span><span class="preprocessor">#define USB_USBSTS_SEI_SHIFT (4U)</span></div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0156086d8d37b3440853817d909fb437">  642</a></span><span class="preprocessor">#define USB_USBSTS_SEI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_SEI_SHIFT) &amp; USB_USBSTS_SEI_MASK)</span></div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af162e2a8fbd78a0b66b52c09b6962763">  643</a></span><span class="preprocessor">#define USB_USBSTS_SEI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_SEI_MASK) &gt;&gt; USB_USBSTS_SEI_SHIFT)</span></div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span> </div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span><span class="comment">/*</span></div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span><span class="comment"> * FRI (RWC)</span></div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span><span class="comment"> *</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span><span class="comment"> * FRI</span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span><span class="comment"> * Frame List Rollover - R/WC.</span></div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span><span class="comment"> * The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to</span></div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span><span class="comment"> * zero. The exact value at which the rollover occurs depends on the frame list size. For example. If the</span></div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span><span class="comment"> * frame list size (as programmed in the Frame List Size field of the USB_n_USBCMD register) is 1024, the</span></div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span><span class="comment"> * Frame Index Register rolls over every time FRINDEX [13] toggles. Similarly, if the size is 512, the Host</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span><span class="comment"> * Controller sets this bit to a one every time FHINDEX [12] toggles.</span></div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span><span class="comment"> * Only used in host operation mode.</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span><span class="comment"> */</span></div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acdab82fa0bea1cd99f0c16241f5c8087">  657</a></span><span class="preprocessor">#define USB_USBSTS_FRI_MASK (0x8U)</span></div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4aaa8ad83986c277286b2d57cf7ff997">  658</a></span><span class="preprocessor">#define USB_USBSTS_FRI_SHIFT (3U)</span></div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9ea39de1b524ffeec5f61ee471014f83">  659</a></span><span class="preprocessor">#define USB_USBSTS_FRI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_FRI_SHIFT) &amp; USB_USBSTS_FRI_MASK)</span></div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acfc10fd85d74851134fb48818b765583">  660</a></span><span class="preprocessor">#define USB_USBSTS_FRI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_FRI_MASK) &gt;&gt; USB_USBSTS_FRI_SHIFT)</span></div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span> </div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span><span class="comment">/*</span></div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment"> * PCI (RWC)</span></div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment"> *</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span><span class="comment"> * PCI</span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment"> * Port Change Detect - R/WC.</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment"> * The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs,</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="comment"> * or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment"> * The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state.</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment"> * When the port controller exits the full or high-speed operation states due to Reset or Suspend events,</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment"> * the notification mechanisms are the USB Reset Received bit and the DCSuspend bits Respectively.</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span><span class="comment"> */</span></div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3b4cc4aff8d433f2b0190f7dee2ceead">  673</a></span><span class="preprocessor">#define USB_USBSTS_PCI_MASK (0x4U)</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ada344fd7a0474429db96313617ded5a2">  674</a></span><span class="preprocessor">#define USB_USBSTS_PCI_SHIFT (2U)</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5bb3ca2234aa6471c300e585d0428335">  675</a></span><span class="preprocessor">#define USB_USBSTS_PCI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_PCI_SHIFT) &amp; USB_USBSTS_PCI_MASK)</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aadaa5c90072aaec6f74dbb7cff81ac9d">  676</a></span><span class="preprocessor">#define USB_USBSTS_PCI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_PCI_MASK) &gt;&gt; USB_USBSTS_PCI_SHIFT)</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span> </div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span><span class="comment">/*</span></div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span><span class="comment"> * UEI (RWC)</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span><span class="comment"> *</span></div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span><span class="comment"> * UEI</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="comment"> * USB Error Interrupt (USBERRINT) - R/WC.</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span><span class="comment"> * When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller.</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span><span class="comment"> * This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.</span></div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span><span class="comment"> */</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a74a7939f51effeac31aaa654b8229eec">  686</a></span><span class="preprocessor">#define USB_USBSTS_UEI_MASK (0x2U)</span></div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab83585f6cc973c020f1c201c0989b107">  687</a></span><span class="preprocessor">#define USB_USBSTS_UEI_SHIFT (1U)</span></div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a472e958b70ad4c1f2f2ca192e633fd23">  688</a></span><span class="preprocessor">#define USB_USBSTS_UEI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_UEI_SHIFT) &amp; USB_USBSTS_UEI_MASK)</span></div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7c90b87dc223693e0d451fe07f80e496">  689</a></span><span class="preprocessor">#define USB_USBSTS_UEI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_UEI_MASK) &gt;&gt; USB_USBSTS_UEI_SHIFT)</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span> </div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span><span class="comment">/*</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span><span class="comment"> * UI (RWC)</span></div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span><span class="comment"> *</span></div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span><span class="comment"> * UI</span></div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span><span class="comment"> * USB Interrupt (USBINT) - R/WC.</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span><span class="comment"> * This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB</span></div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span><span class="comment"> * transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.</span></div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span><span class="comment"> * This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when</span></div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span><span class="comment"> * the actual number of bytes received was less than the expected number of bytes.</span></div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span><span class="comment"> */</span></div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7b6c9fb90b9698a477a340c2dbabdcc5">  701</a></span><span class="preprocessor">#define USB_USBSTS_UI_MASK (0x1U)</span></div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3da4cb43e8992708858720fad21e1383">  702</a></span><span class="preprocessor">#define USB_USBSTS_UI_SHIFT (0U)</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a266a57d503b878d75170eaab5d9173a0">  703</a></span><span class="preprocessor">#define USB_USBSTS_UI_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBSTS_UI_SHIFT) &amp; USB_USBSTS_UI_MASK)</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae4e5165feb0bab39faef13353e970d3d">  704</a></span><span class="preprocessor">#define USB_USBSTS_UI_GET(x) (((uint32_t)(x) &amp; USB_USBSTS_UI_MASK) &gt;&gt; USB_USBSTS_UI_SHIFT)</span></div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span> </div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span><span class="comment">/* Bitfield definition for register: USBINTR */</span></div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span><span class="comment">/*</span></div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span><span class="comment"> * TIE1 (RW)</span></div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span><span class="comment"> *</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span><span class="comment"> * TIE1</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span><span class="comment"> * General Purpose Timer #1 Interrupt Enable</span></div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span><span class="comment"> * When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span><span class="comment"> */</span></div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4f3671cd33c028158f1697a6fb92bede">  714</a></span><span class="preprocessor">#define USB_USBINTR_TIE1_MASK (0x2000000UL)</span></div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a050ed38465d3bec5319cb6f3cb1b59de">  715</a></span><span class="preprocessor">#define USB_USBINTR_TIE1_SHIFT (25U)</span></div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a03cd4a3684d6b4943302aa1f374d4e7f">  716</a></span><span class="preprocessor">#define USB_USBINTR_TIE1_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_TIE1_SHIFT) &amp; USB_USBINTR_TIE1_MASK)</span></div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac289c2db7e8330f9d88a6b22155966e9">  717</a></span><span class="preprocessor">#define USB_USBINTR_TIE1_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_TIE1_MASK) &gt;&gt; USB_USBINTR_TIE1_SHIFT)</span></div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span> </div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span><span class="comment">/*</span></div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span><span class="comment"> * TIE0 (RW)</span></div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span><span class="comment"> *</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span><span class="comment"> * TIE0</span></div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span><span class="comment"> * General Purpose Timer #0 Interrupt Enable</span></div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span><span class="comment"> * When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span><span class="comment"> */</span></div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a55a25ece24db114793f6eb7738f615b2">  726</a></span><span class="preprocessor">#define USB_USBINTR_TIE0_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a784939c2fc3512289a5e5c74fb73aed7">  727</a></span><span class="preprocessor">#define USB_USBINTR_TIE0_SHIFT (24U)</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae3c06e31715ba5f276568197472f546e">  728</a></span><span class="preprocessor">#define USB_USBINTR_TIE0_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_TIE0_SHIFT) &amp; USB_USBINTR_TIE0_MASK)</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5ec70999ec0343868b4f1957a92dcc72">  729</a></span><span class="preprocessor">#define USB_USBINTR_TIE0_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_TIE0_MASK) &gt;&gt; USB_USBINTR_TIE0_SHIFT)</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span> </div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span><span class="comment">/*</span></div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span><span class="comment"> * UPIE (RW)</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span><span class="comment"> *</span></div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span><span class="comment"> * UPIE</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment"> * USB Host Periodic Interrupt Enable</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment"> * When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span><span class="comment"> * interrupt at the next interrupt threshold.</span></div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span><span class="comment"> */</span></div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5f8c0ed89e5d5a086bf3273c3f605ebc">  739</a></span><span class="preprocessor">#define USB_USBINTR_UPIE_MASK (0x80000UL)</span></div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af3d7cc61dc3a31e8d613dbe2685feefe">  740</a></span><span class="preprocessor">#define USB_USBINTR_UPIE_SHIFT (19U)</span></div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad579e14967e703614c3a4410e7566123">  741</a></span><span class="preprocessor">#define USB_USBINTR_UPIE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_UPIE_SHIFT) &amp; USB_USBINTR_UPIE_MASK)</span></div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7aa4cf27581d8160f21a71f20a38d51a">  742</a></span><span class="preprocessor">#define USB_USBINTR_UPIE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_UPIE_MASK) &gt;&gt; USB_USBINTR_UPIE_SHIFT)</span></div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span> </div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span><span class="comment">/*</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span><span class="comment"> * UAIE (RW)</span></div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span><span class="comment"> *</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="comment"> * UAIE</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span><span class="comment"> * USB Host Asynchronous Interrupt Enable</span></div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="comment"> * When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span><span class="comment"> * interrupt at the next interrupt threshold.</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span><span class="comment"> */</span></div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a617d350688239c5d6dcbfb748ad3a3f3">  752</a></span><span class="preprocessor">#define USB_USBINTR_UAIE_MASK (0x40000UL)</span></div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c3461452b7ec904ba6883f58b0883cd">  753</a></span><span class="preprocessor">#define USB_USBINTR_UAIE_SHIFT (18U)</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2fb1d2f0f6982da68e08835b232eda93">  754</a></span><span class="preprocessor">#define USB_USBINTR_UAIE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_UAIE_SHIFT) &amp; USB_USBINTR_UAIE_MASK)</span></div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a48e3226bc90c0a84c0bc8faa7fd4683d">  755</a></span><span class="preprocessor">#define USB_USBINTR_UAIE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_UAIE_MASK) &gt;&gt; USB_USBINTR_UAIE_SHIFT)</span></div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span> </div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span><span class="comment">/*</span></div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="comment"> * NAKE (RO)</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="comment"> *</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span><span class="comment"> * NAKE</span></div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span><span class="comment"> * NAK Interrupt Enable</span></div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span><span class="comment"> * When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span><span class="comment"> */</span></div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4985f74b10462f12f83500a25a154442">  764</a></span><span class="preprocessor">#define USB_USBINTR_NAKE_MASK (0x10000UL)</span></div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0725ddf0b991f94f01329167c9858da7">  765</a></span><span class="preprocessor">#define USB_USBINTR_NAKE_SHIFT (16U)</span></div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a528f6e651f1798fecbee5ccc8bcac677">  766</a></span><span class="preprocessor">#define USB_USBINTR_NAKE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_NAKE_MASK) &gt;&gt; USB_USBINTR_NAKE_SHIFT)</span></div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span> </div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span><span class="comment">/*</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment"> * SLE (RW)</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment"> *</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span><span class="comment"> * SLE</span></div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span><span class="comment"> * Sleep Interrupt Enable</span></div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span><span class="comment"> * When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span><span class="comment"> * Only used in device operation mode.</span></div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span><span class="comment"> */</span></div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9288880ef9ca7e7b2e412c36fe5524fc">  776</a></span><span class="preprocessor">#define USB_USBINTR_SLE_MASK (0x100U)</span></div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af466b4d817f6788bcf9bec096687436c">  777</a></span><span class="preprocessor">#define USB_USBINTR_SLE_SHIFT (8U)</span></div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac78b23739467b443f3e7ab944072080f">  778</a></span><span class="preprocessor">#define USB_USBINTR_SLE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_SLE_SHIFT) &amp; USB_USBINTR_SLE_MASK)</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa6a07fc8eb833f1c3de5ddb0443db3c4">  779</a></span><span class="preprocessor">#define USB_USBINTR_SLE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_SLE_MASK) &gt;&gt; USB_USBINTR_SLE_SHIFT)</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span> </div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">/*</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span><span class="comment"> * SRE (RW)</span></div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment"> *</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span><span class="comment"> * SRE</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment"> * SOF Received Interrupt Enable</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment"> * When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span><span class="comment"> */</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af5f835bab6f29e3a3d1c59397c847c4c">  788</a></span><span class="preprocessor">#define USB_USBINTR_SRE_MASK (0x80U)</span></div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2ae3ac821510667d45239276f18ddf2e">  789</a></span><span class="preprocessor">#define USB_USBINTR_SRE_SHIFT (7U)</span></div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7ea3bfe0823dc0a07614c520426c368b">  790</a></span><span class="preprocessor">#define USB_USBINTR_SRE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_SRE_SHIFT) &amp; USB_USBINTR_SRE_MASK)</span></div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a08b78d2bff59d43cf81152c29d81a3e0">  791</a></span><span class="preprocessor">#define USB_USBINTR_SRE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_SRE_MASK) &gt;&gt; USB_USBINTR_SRE_SHIFT)</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span> </div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span><span class="comment">/*</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span><span class="comment"> * URE (RW)</span></div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span><span class="comment"> *</span></div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span><span class="comment"> * URE</span></div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span><span class="comment"> * USB Reset Interrupt Enable</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span><span class="comment"> * When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span><span class="comment"> * Only used in device operation mode.</span></div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span><span class="comment"> */</span></div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0bb91ac5317a40aa79bd077afb979817">  801</a></span><span class="preprocessor">#define USB_USBINTR_URE_MASK (0x40U)</span></div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a11b8ef4a4ee2ed57ac2943e3f17a2523">  802</a></span><span class="preprocessor">#define USB_USBINTR_URE_SHIFT (6U)</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a32751413fc3491c81a6e71daa71a939c">  803</a></span><span class="preprocessor">#define USB_USBINTR_URE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_URE_SHIFT) &amp; USB_USBINTR_URE_MASK)</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a675d26e7e1ade31f9c32598af851f572">  804</a></span><span class="preprocessor">#define USB_USBINTR_URE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_URE_MASK) &gt;&gt; USB_USBINTR_URE_SHIFT)</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span> </div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span><span class="comment">/*</span></div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span><span class="comment"> * AAE (RW)</span></div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span><span class="comment"> *</span></div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span><span class="comment"> * AAE</span></div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span><span class="comment"> * Async Advance Interrupt Enable</span></div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span><span class="comment"> * When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span><span class="comment"> * Only used in host operation mode.</span></div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span><span class="comment"> */</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7cce01ef5d4f188f49ea4ce6065c7474">  814</a></span><span class="preprocessor">#define USB_USBINTR_AAE_MASK (0x20U)</span></div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2d647e37eaedffe242853f30f87e5043">  815</a></span><span class="preprocessor">#define USB_USBINTR_AAE_SHIFT (5U)</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a62012306c75b4760906ca4fb92643adb">  816</a></span><span class="preprocessor">#define USB_USBINTR_AAE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_AAE_SHIFT) &amp; USB_USBINTR_AAE_MASK)</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af911fa27ab4469dfb5db29f436285692">  817</a></span><span class="preprocessor">#define USB_USBINTR_AAE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_AAE_MASK) &gt;&gt; USB_USBINTR_AAE_SHIFT)</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span> </div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment">/*</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span><span class="comment"> * SEE (RW)</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span><span class="comment"> *</span></div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span><span class="comment"> * SEE</span></div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span><span class="comment"> * System Error Interrupt Enable</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span><span class="comment"> * When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span><span class="comment"> * Only used in host operation mode.</span></div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span><span class="comment"> */</span></div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab19d0d6793dd801799cc96233353e0fb">  827</a></span><span class="preprocessor">#define USB_USBINTR_SEE_MASK (0x10U)</span></div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac1dd00de8cf8bc37d6d5fce9b2ea86c4">  828</a></span><span class="preprocessor">#define USB_USBINTR_SEE_SHIFT (4U)</span></div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afc5d4cc4319d8fb0d7ce0fe9c23874c0">  829</a></span><span class="preprocessor">#define USB_USBINTR_SEE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_SEE_SHIFT) &amp; USB_USBINTR_SEE_MASK)</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aeabfdc10d486f56c7de287781fa50fa6">  830</a></span><span class="preprocessor">#define USB_USBINTR_SEE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_SEE_MASK) &gt;&gt; USB_USBINTR_SEE_SHIFT)</span></div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span> </div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span><span class="comment">/*</span></div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span><span class="comment"> * FRE (RW)</span></div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span><span class="comment"> *</span></div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span><span class="comment"> * FRE</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span><span class="comment"> * Frame List Rollover Interrupt Enable</span></div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span><span class="comment"> * When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span><span class="comment"> * Only used in host operation mode.</span></div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span><span class="comment"> */</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8ec1f05a7f8bbc62afeecfbbb81df92c">  840</a></span><span class="preprocessor">#define USB_USBINTR_FRE_MASK (0x8U)</span></div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a254cea730838a0083ada1e4a0d077489">  841</a></span><span class="preprocessor">#define USB_USBINTR_FRE_SHIFT (3U)</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab91e72cc39ed2ce785b42c37ad82fd68">  842</a></span><span class="preprocessor">#define USB_USBINTR_FRE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_FRE_SHIFT) &amp; USB_USBINTR_FRE_MASK)</span></div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac612da51d4ae70d33f43e43b553e5031">  843</a></span><span class="preprocessor">#define USB_USBINTR_FRE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_FRE_MASK) &gt;&gt; USB_USBINTR_FRE_SHIFT)</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span> </div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span><span class="comment">/*</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span><span class="comment"> * PCE (RW)</span></div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment"> *</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span><span class="comment"> * PCE</span></div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span><span class="comment"> * Port Change Detect Interrupt Enable</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span><span class="comment"> * When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span><span class="comment"> */</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6896efc5b9d9dedd9a051a739a303b77">  852</a></span><span class="preprocessor">#define USB_USBINTR_PCE_MASK (0x4U)</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad46e794a99af23df9160ffa096c3ce5d">  853</a></span><span class="preprocessor">#define USB_USBINTR_PCE_SHIFT (2U)</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad087c7a2914561da462a98422d7d9458">  854</a></span><span class="preprocessor">#define USB_USBINTR_PCE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_PCE_SHIFT) &amp; USB_USBINTR_PCE_MASK)</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa3ddd3a36540d5b2ddf1895adf257884">  855</a></span><span class="preprocessor">#define USB_USBINTR_PCE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_PCE_MASK) &gt;&gt; USB_USBINTR_PCE_SHIFT)</span></div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span> </div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span><span class="comment">/*</span></div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span><span class="comment"> * UEE (RWC)</span></div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span><span class="comment"> *</span></div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span><span class="comment"> * UEE</span></div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span><span class="comment"> * USB Error Interrupt Enable</span></div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span><span class="comment"> * When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span><span class="comment"> */</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c019564d517e7acf35d1c2d91d920c0">  864</a></span><span class="preprocessor">#define USB_USBINTR_UEE_MASK (0x2U)</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ada8e83201c587c73d5930cf7bd6e22ed">  865</a></span><span class="preprocessor">#define USB_USBINTR_UEE_SHIFT (1U)</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa3414b874e5e8c3f1a0a8f0af2f47f90">  866</a></span><span class="preprocessor">#define USB_USBINTR_UEE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_UEE_SHIFT) &amp; USB_USBINTR_UEE_MASK)</span></div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a752189a4efa28405634a390b1d7ba20e">  867</a></span><span class="preprocessor">#define USB_USBINTR_UEE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_UEE_MASK) &gt;&gt; USB_USBINTR_UEE_SHIFT)</span></div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span> </div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span><span class="comment">/*</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span><span class="comment"> * UE (RW)</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span><span class="comment"> *</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span><span class="comment"> * UE</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span><span class="comment"> * USB Interrupt Enable</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span><span class="comment"> * When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt.</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span><span class="comment"> */</span></div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa1e2957167450f17ea2898c34f0c6329">  876</a></span><span class="preprocessor">#define USB_USBINTR_UE_MASK (0x1U)</span></div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9490146e5ff4f6501efaee41b29cd68a">  877</a></span><span class="preprocessor">#define USB_USBINTR_UE_SHIFT (0U)</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acb923930e35e9a7dfbc20cebf355be83">  878</a></span><span class="preprocessor">#define USB_USBINTR_UE_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBINTR_UE_SHIFT) &amp; USB_USBINTR_UE_MASK)</span></div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa17c60df3f2c290d2c7f6e4bf8d98b50">  879</a></span><span class="preprocessor">#define USB_USBINTR_UE_GET(x) (((uint32_t)(x) &amp; USB_USBINTR_UE_MASK) &gt;&gt; USB_USBINTR_UE_SHIFT)</span></div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span> </div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span><span class="comment">/* Bitfield definition for register: FRINDEX */</span></div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span><span class="comment">/*</span></div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span><span class="comment"> * FRINDEX (RW)</span></div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span><span class="comment"> *</span></div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span><span class="comment"> * FRINDEX</span></div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span><span class="comment"> * Frame Index.</span></div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span><span class="comment"> * The value, in this register, increments at the end of each time frame (micro-frame). Bits [N: 3] are used for the Frame List current index.</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span><span class="comment"> * This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span><span class="comment"> * The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.</span></div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span><span class="comment"> * USBCMD [Frame List Size] Number Elements N</span></div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span><span class="comment"> * In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.</span></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span><span class="comment"> * In either mode bits 2:0 indicate the current microframe.</span></div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span><span class="comment"> * The bit field values description below is represented as (Frame List Size) Number Elements N.</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span><span class="comment"> * 00000000000000 - (1024) 12</span></div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span><span class="comment"> * 00000000000001 - (512) 11</span></div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span><span class="comment"> * 00000000000010 - (256) 10</span></div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span><span class="comment"> * 00000000000011 - (128) 9</span></div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span><span class="comment"> * 00000000000100 - (64) 8</span></div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="comment"> * 00000000000101 - (32) 7</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="comment"> * 00000000000110 - (16) 6</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span><span class="comment"> * 00000000000111 - (8) 5</span></div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="comment"> */</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab1382728913c503e57e37b719db7928a">  903</a></span><span class="preprocessor">#define USB_FRINDEX_FRINDEX_MASK (0x3FFFU)</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a938e3fd933bf5d0f1b775cf9e7e9f31c">  904</a></span><span class="preprocessor">#define USB_FRINDEX_FRINDEX_SHIFT (0U)</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae08aad6ab0ba0410ef21f7f4921a05e1">  905</a></span><span class="preprocessor">#define USB_FRINDEX_FRINDEX_SET(x) (((uint32_t)(x) &lt;&lt; USB_FRINDEX_FRINDEX_SHIFT) &amp; USB_FRINDEX_FRINDEX_MASK)</span></div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a233e21e6d3eef467731be3628689ca45">  906</a></span><span class="preprocessor">#define USB_FRINDEX_FRINDEX_GET(x) (((uint32_t)(x) &amp; USB_FRINDEX_FRINDEX_MASK) &gt;&gt; USB_FRINDEX_FRINDEX_SHIFT)</span></div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span> </div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span><span class="comment">/* Bitfield definition for register: DEVICEADDR */</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span><span class="comment">/*</span></div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span><span class="comment"> * USBADR (RW)</span></div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="comment"> *</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span><span class="comment"> * USBADR</span></div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span><span class="comment"> * Device Address.</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span><span class="comment"> * These bits correspond to the USB device address</span></div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span><span class="comment"> */</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abe748a5173c4e736ab20a8829c7387c0">  916</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADR_MASK (0xFE000000UL)</span></div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae5e8d51c64470ac282b1a034b6870a1c">  917</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADR_SHIFT (25U)</span></div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a34bee051630a68f7ed0f806e96b77313">  918</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADR_SET(x) (((uint32_t)(x) &lt;&lt; USB_DEVICEADDR_USBADR_SHIFT) &amp; USB_DEVICEADDR_USBADR_MASK)</span></div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8f518d31cccabe9d7fb7a15a72c120de">  919</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADR_GET(x) (((uint32_t)(x) &amp; USB_DEVICEADDR_USBADR_MASK) &gt;&gt; USB_DEVICEADDR_USBADR_SHIFT)</span></div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span> </div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span><span class="comment">/*</span></div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span><span class="comment"> * USBADRA (RW)</span></div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span><span class="comment"> *</span></div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span><span class="comment"> * USBADRA</span></div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span><span class="comment"> * Device Address Advance. Default=0.</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span><span class="comment"> * When this bit is &#39;0&#39;, any writes to USBADR are instantaneous.</span></div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span><span class="comment"> *  When this bit is written to a &#39;1&#39; at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register.</span></div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span><span class="comment"> * After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register.</span></div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span><span class="comment"> * Hardware will automatically clear this bit on the following conditions:</span></div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span><span class="comment"> * 1) IN is ACKed to endpoint 0. (USBADR is updated from staging register).</span></div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span><span class="comment"> * 2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span><span class="comment"> * 3) Device Reset occurs (USBADR is reset to 0).</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span><span class="comment"> * NOTE: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field.</span></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span><span class="comment"> * This mechanism will ensure this specification is met when the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.</span></div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span><span class="comment"> * If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase),</span></div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span><span class="comment"> * the USBADR will be programmed instantly at the correct time and meet the 2ms USB requirement.</span></div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span><span class="comment"> */</span></div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aefec79f98437560067c820fcfae832da">  938</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADRA_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a39b1fe6dc26c28e87318a169367b159a">  939</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADRA_SHIFT (24U)</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab086e3385788d8e79a9a51c40a780bc5">  940</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADRA_SET(x) (((uint32_t)(x) &lt;&lt; USB_DEVICEADDR_USBADRA_SHIFT) &amp; USB_DEVICEADDR_USBADRA_MASK)</span></div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6fd7959361d03f52efd5f62a391c4bc1">  941</a></span><span class="preprocessor">#define USB_DEVICEADDR_USBADRA_GET(x) (((uint32_t)(x) &amp; USB_DEVICEADDR_USBADRA_MASK) &gt;&gt; USB_DEVICEADDR_USBADRA_SHIFT)</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span> </div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span><span class="comment">/* Bitfield definition for register: PERIODICLISTBASE */</span></div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span><span class="comment">/*</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span><span class="comment"> * BASEADR (RW)</span></div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span><span class="comment"> *</span></div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span><span class="comment"> * BASEADR</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span><span class="comment"> * Base Address (Low).</span></div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span><span class="comment"> * These bits correspond to memory address signals [31:12], respectively.</span></div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span><span class="comment"> * Only used by the host controller.</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span><span class="comment"> */</span></div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7a42b440a18012dc71c1ad02a7c255c7">  952</a></span><span class="preprocessor">#define USB_PERIODICLISTBASE_BASEADR_MASK (0xFFFFF000UL)</span></div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a67d4dd287c1428c0551ab038170d9736">  953</a></span><span class="preprocessor">#define USB_PERIODICLISTBASE_BASEADR_SHIFT (12U)</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afd049e2712ddde9a626d7069c2d539cd">  954</a></span><span class="preprocessor">#define USB_PERIODICLISTBASE_BASEADR_SET(x) (((uint32_t)(x) &lt;&lt; USB_PERIODICLISTBASE_BASEADR_SHIFT) &amp; USB_PERIODICLISTBASE_BASEADR_MASK)</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a77b8372dab9aa48fdea37aa7d8150d7d">  955</a></span><span class="preprocessor">#define USB_PERIODICLISTBASE_BASEADR_GET(x) (((uint32_t)(x) &amp; USB_PERIODICLISTBASE_BASEADR_MASK) &gt;&gt; USB_PERIODICLISTBASE_BASEADR_SHIFT)</span></div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span> </div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span><span class="comment">/* Bitfield definition for register: ASYNCLISTADDR */</span></div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span><span class="comment">/*</span></div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span><span class="comment"> * ASYBASE (RW)</span></div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span><span class="comment"> *</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span><span class="comment"> * ASYBASE</span></div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span><span class="comment"> * Link Pointer Low (LPL).</span></div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span><span class="comment"> * These bits correspond to memory address signals [31:5], respectively. This field may only reference a</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span><span class="comment"> * Queue Head (QH).</span></div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span><span class="comment"> * Only used by the host controller.</span></div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span><span class="comment"> */</span></div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a19a4a12c1b4a7699d39fb0b3fd204566">  967</a></span><span class="preprocessor">#define USB_ASYNCLISTADDR_ASYBASE_MASK (0xFFFFFFE0UL)</span></div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aaf80a2b7bb0b41778f3fb4f9cbf5c4ee">  968</a></span><span class="preprocessor">#define USB_ASYNCLISTADDR_ASYBASE_SHIFT (5U)</span></div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6ecc3c97dbd3e605e67b8b378e629f9f">  969</a></span><span class="preprocessor">#define USB_ASYNCLISTADDR_ASYBASE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ASYNCLISTADDR_ASYBASE_SHIFT) &amp; USB_ASYNCLISTADDR_ASYBASE_MASK)</span></div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aeee7eab00ac11f83fe4e49a7ce2343f7">  970</a></span><span class="preprocessor">#define USB_ASYNCLISTADDR_ASYBASE_GET(x) (((uint32_t)(x) &amp; USB_ASYNCLISTADDR_ASYBASE_MASK) &gt;&gt; USB_ASYNCLISTADDR_ASYBASE_SHIFT)</span></div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span> </div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span><span class="comment">/* Bitfield definition for register: ENDPTLISTADDR */</span></div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span><span class="comment">/*</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span><span class="comment"> * EPBASE (RW)</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span><span class="comment"> *</span></div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span><span class="comment"> * EPBASE</span></div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span><span class="comment"> * Endpoint List Pointer(Low). These bits correspond to memory address signals [31:11], respectively.</span></div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span><span class="comment"> * This field will reference a list of up to 32 Queue Head (QH) (that is, one queue head per endpoint &amp; direction).</span></div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span><span class="comment"> */</span></div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af5cb78e286db1a938bda65f9d43f7457">  980</a></span><span class="preprocessor">#define USB_ENDPTLISTADDR_EPBASE_MASK (0xFFFFF800UL)</span></div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae2b4b505a14baeae86a5b4f0e351593f">  981</a></span><span class="preprocessor">#define USB_ENDPTLISTADDR_EPBASE_SHIFT (11U)</span></div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3c2124b59c56d2351b2acd8702ea22ff">  982</a></span><span class="preprocessor">#define USB_ENDPTLISTADDR_EPBASE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTLISTADDR_EPBASE_SHIFT) &amp; USB_ENDPTLISTADDR_EPBASE_MASK)</span></div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad450cc2cc62a4431e00232f0f0c66070">  983</a></span><span class="preprocessor">#define USB_ENDPTLISTADDR_EPBASE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTLISTADDR_EPBASE_MASK) &gt;&gt; USB_ENDPTLISTADDR_EPBASE_SHIFT)</span></div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span> </div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span><span class="comment">/* Bitfield definition for register: BURSTSIZE */</span></div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span><span class="comment">/*</span></div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span><span class="comment"> * TXPBURST (RW)</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span><span class="comment"> *</span></div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span><span class="comment"> * TXPBURST</span></div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span><span class="comment"> * Programmable TX Burst Size.</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span><span class="comment"> * Default value is determined by TXBURST bits in n_HWTXBUF.</span></div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span><span class="comment"> * This register represents the maximum length of a the burst in 32-bit words while moving data from system</span></div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span><span class="comment"> * memory to the USB bus.</span></div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span><span class="comment"> */</span></div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adfd9861905f5384b6ec63c780a504faf">  995</a></span><span class="preprocessor">#define USB_BURSTSIZE_TXPBURST_MASK (0xFF00U)</span></div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6fcf88e21589bcb9b88b74908bcdc87c">  996</a></span><span class="preprocessor">#define USB_BURSTSIZE_TXPBURST_SHIFT (8U)</span></div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac85d4d385435060483acb560ed56fd11">  997</a></span><span class="preprocessor">#define USB_BURSTSIZE_TXPBURST_SET(x) (((uint32_t)(x) &lt;&lt; USB_BURSTSIZE_TXPBURST_SHIFT) &amp; USB_BURSTSIZE_TXPBURST_MASK)</span></div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a12b477c9d9b6cb97dc96456e5e834a17">  998</a></span><span class="preprocessor">#define USB_BURSTSIZE_TXPBURST_GET(x) (((uint32_t)(x) &amp; USB_BURSTSIZE_TXPBURST_MASK) &gt;&gt; USB_BURSTSIZE_TXPBURST_SHIFT)</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span> </div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span><span class="comment">/*</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span><span class="comment"> * RXPBURST (RW)</span></div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span><span class="comment"> *</span></div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span><span class="comment"> * RXPBURST</span></div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span><span class="comment"> * Programmable RX Burst Size.</span></div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span><span class="comment"> * Default value is determined by TXBURST bits in n_HWRXBUF.</span></div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span><span class="comment"> * This register represents the maximum length of a the burst in 32-bit words while moving data from the</span></div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span><span class="comment"> * USB bus to system memory.</span></div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span><span class="comment"> */</span></div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a994a01e644a66af57402f5617e7abe73"> 1009</a></span><span class="preprocessor">#define USB_BURSTSIZE_RXPBURST_MASK (0xFFU)</span></div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac2a279a3646087bb9037f3e8ad35b379"> 1010</a></span><span class="preprocessor">#define USB_BURSTSIZE_RXPBURST_SHIFT (0U)</span></div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2786ae6307d1aa89bfa4307aff97f926"> 1011</a></span><span class="preprocessor">#define USB_BURSTSIZE_RXPBURST_SET(x) (((uint32_t)(x) &lt;&lt; USB_BURSTSIZE_RXPBURST_SHIFT) &amp; USB_BURSTSIZE_RXPBURST_MASK)</span></div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a89938186ed9a4270dbaee5e7b7a89509"> 1012</a></span><span class="preprocessor">#define USB_BURSTSIZE_RXPBURST_GET(x) (((uint32_t)(x) &amp; USB_BURSTSIZE_RXPBURST_MASK) &gt;&gt; USB_BURSTSIZE_RXPBURST_SHIFT)</span></div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span> </div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span><span class="comment">/* Bitfield definition for register: TXFILLTUNING */</span></div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span><span class="comment">/*</span></div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span><span class="comment"> * TXFIFOTHRES (RW)</span></div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span><span class="comment"> *</span></div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span><span class="comment"> * TXFIFOTHRES</span></div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span><span class="comment"> * FIFO Burst Threshold. (Read/Write)</span></div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span><span class="comment"> * This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.</span></div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span><span class="comment"> * The minimum value is 2 and this value should be a low as possible to maximize USB performance.</span></div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span><span class="comment"> * A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth</span></div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span><span class="comment"> * where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.</span></div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span><span class="comment"> * This value is ignored if the Stream Disable bit in USB_n_USBMODE register is set.</span></div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span><span class="comment"> */</span></div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af1db607c64d1efb275bbd038e6e27b10"> 1026</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXFIFOTHRES_MASK (0x3F0000UL)</span></div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a50299543f032e4a39a2a08c8ca2a5847"> 1027</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXFIFOTHRES_SHIFT (16U)</span></div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a201ecd5a9c8b057b56096c1d8979db05"> 1028</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXFIFOTHRES_SET(x) (((uint32_t)(x) &lt;&lt; USB_TXFILLTUNING_TXFIFOTHRES_SHIFT) &amp; USB_TXFILLTUNING_TXFIFOTHRES_MASK)</span></div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a30a26fb3019fa85e92661b360148861b"> 1029</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXFIFOTHRES_GET(x) (((uint32_t)(x) &amp; USB_TXFILLTUNING_TXFIFOTHRES_MASK) &gt;&gt; USB_TXFILLTUNING_TXFIFOTHRES_SHIFT)</span></div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span> </div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span><span class="comment">/*</span></div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span><span class="comment"> * TXSCHHEALTH (RWC)</span></div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span><span class="comment"> *</span></div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span><span class="comment"> * TXSCHHEALTH</span></div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span><span class="comment"> * Scheduler Health Counter. (Read/Write To Clear)</span></div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span><span class="comment"> * Table continues on the next page</span></div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span><span class="comment"> * This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES</span></div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span><span class="comment"> * before running out of time to send the packet before the next Start-Of-Frame.</span></div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span><span class="comment"> * This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.</span></div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span><span class="comment"> * Writing to this register will clear the counter and this counter will max. at 31.</span></div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"> 1041</span><span class="comment"> */</span></div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aabd415083588438f22f6185aa3fbd4b4"> 1042</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHHEALTH_MASK (0x1F00U)</span></div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3a5708f17e48fad2ec0a3c606be0b1ed"> 1043</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHHEALTH_SHIFT (8U)</span></div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acc1656d65df7419dcd563774836b6a1a"> 1044</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHHEALTH_SET(x) (((uint32_t)(x) &lt;&lt; USB_TXFILLTUNING_TXSCHHEALTH_SHIFT) &amp; USB_TXFILLTUNING_TXSCHHEALTH_MASK)</span></div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a10973ab9485c13e828df971806365527"> 1045</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHHEALTH_GET(x) (((uint32_t)(x) &amp; USB_TXFILLTUNING_TXSCHHEALTH_MASK) &gt;&gt; USB_TXFILLTUNING_TXSCHHEALTH_SHIFT)</span></div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span> </div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"> 1047</span><span class="comment">/*</span></div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span><span class="comment"> * TXSCHOH (RW)</span></div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span><span class="comment"> *</span></div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span><span class="comment"> * TXSCHOH</span></div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span><span class="comment"> * Scheduler Overhead. (Read/Write) [Default = 0]</span></div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span><span class="comment"> * This register adds an additional fixed offset to the schedule time estimator described above as Tff.</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span><span class="comment"> * As an approximation, the value chosen for this register should limit the number of back-off events captured</span></div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span><span class="comment"> * in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.</span></div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span><span class="comment"> * Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.</span></div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span><span class="comment"> * The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode.</span></div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span><span class="comment"> * The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode.</span></div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span><span class="comment"> * Default value is &#39;08h&#39; for OTG controller core .</span></div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span><span class="comment"> */</span></div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af5dd87fd51cc515559aa0855c2119f5c"> 1060</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHOH_MASK (0x7FU)</span></div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a294806165820e4e096a8400d8dd79cb4"> 1061</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHOH_SHIFT (0U)</span></div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac7b33c27f0616ab19cd7314ee84feefd"> 1062</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHOH_SET(x) (((uint32_t)(x) &lt;&lt; USB_TXFILLTUNING_TXSCHOH_SHIFT) &amp; USB_TXFILLTUNING_TXSCHOH_MASK)</span></div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1b896f9149650ad886f65e860f3d1a25"> 1063</a></span><span class="preprocessor">#define USB_TXFILLTUNING_TXSCHOH_GET(x) (((uint32_t)(x) &amp; USB_TXFILLTUNING_TXSCHOH_MASK) &gt;&gt; USB_TXFILLTUNING_TXSCHOH_SHIFT)</span></div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span> </div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span><span class="comment">/* Bitfield definition for register: ENDPTNAK */</span></div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span><span class="comment">/*</span></div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span><span class="comment"> * EPTN (RWC)</span></div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span><span class="comment"> *</span></div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span><span class="comment"> * EPTN</span></div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span><span class="comment"> * TX Endpoint NAK - R/WC.</span></div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span><span class="comment"> * Each TX endpoint has 1 bit in this field. The bit is set when the</span></div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span><span class="comment"> * device sends a NAK handshake on a received IN token for the corresponding endpoint.</span></div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span><span class="comment"> * Bit [N] - Endpoint #[N], N is 0-7</span></div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span><span class="comment"> */</span></div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aec19b200c62967989a8e83f0dfaaa8fe"> 1075</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPTN_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a04473b465c62e050ff6fbdaec71737a2"> 1076</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPTN_SHIFT (16U)</span></div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8689fc8efe7d42de8a45986201d19f51"> 1077</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPTN_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTNAK_EPTN_SHIFT) &amp; USB_ENDPTNAK_EPTN_MASK)</span></div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa31c6e91de8643a1634fbc9168125b5a"> 1078</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPTN_GET(x) (((uint32_t)(x) &amp; USB_ENDPTNAK_EPTN_MASK) &gt;&gt; USB_ENDPTNAK_EPTN_SHIFT)</span></div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"> 1079</span> </div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span><span class="comment">/*</span></div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span><span class="comment"> * EPRN (RWC)</span></div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span><span class="comment"> *</span></div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span><span class="comment"> * EPRN</span></div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span><span class="comment"> * RX Endpoint NAK - R/WC.</span></div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span><span class="comment"> * Each RX endpoint has 1 bit in this field. The bit is set when the</span></div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span><span class="comment"> * device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.</span></div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span><span class="comment"> * Bit [N] - Endpoint #[N], N is 0-7</span></div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span><span class="comment"> */</span></div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1d38b20d78673c58f53968c387ac6180"> 1089</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPRN_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9e7ef6ac56df382770de2c6dbf958658"> 1090</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPRN_SHIFT (0U)</span></div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a21036d41a62e15520d3f076caccd14be"> 1091</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPRN_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTNAK_EPRN_SHIFT) &amp; USB_ENDPTNAK_EPRN_MASK)</span></div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8fabbb586ea57cc6b7fe4ef22d5f1d72"> 1092</a></span><span class="preprocessor">#define USB_ENDPTNAK_EPRN_GET(x) (((uint32_t)(x) &amp; USB_ENDPTNAK_EPRN_MASK) &gt;&gt; USB_ENDPTNAK_EPRN_SHIFT)</span></div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span> </div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span><span class="comment">/* Bitfield definition for register: ENDPTNAKEN */</span></div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span><span class="comment">/*</span></div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span><span class="comment"> * EPTNE (RW)</span></div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span><span class="comment"> *</span></div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span><span class="comment"> * EPTNE</span></div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span><span class="comment"> * TX Endpoint NAK Enable - R/W.</span></div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span><span class="comment"> * Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the</span></div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span><span class="comment"> * corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span><span class="comment"> * Bit [N] - Endpoint #[N], N is 0-7</span></div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span><span class="comment"> */</span></div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac13e2495a11bdbae4cc0e4e35e61f950"> 1104</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPTNE_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac7b58d76d2b3b0cc8de3d16a0bde04d0"> 1105</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPTNE_SHIFT (16U)</span></div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a480ce5e9b6f11227176f81282635b8f1"> 1106</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPTNE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTNAKEN_EPTNE_SHIFT) &amp; USB_ENDPTNAKEN_EPTNE_MASK)</span></div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab1af971dca4f5c838e892e36ec5cabc7"> 1107</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPTNE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTNAKEN_EPTNE_MASK) &gt;&gt; USB_ENDPTNAKEN_EPTNE_SHIFT)</span></div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span> </div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span><span class="comment">/*</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span><span class="comment"> * EPRNE (RW)</span></div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span><span class="comment"> *</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span><span class="comment"> * EPRNE</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span><span class="comment"> * RX Endpoint NAK Enable - R/W.</span></div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span><span class="comment"> * Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the</span></div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span><span class="comment"> * corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.</span></div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span><span class="comment"> * Bit [N] - Endpoint #[N], N is 0-7</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span><span class="comment"> */</span></div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a43a22dbe114cbad45d461b39c9860b8b"> 1118</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPRNE_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a396ff34dd55a36b2aa438d3c6c2a05fc"> 1119</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPRNE_SHIFT (0U)</span></div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9da4b6b35450c673bff1a70599713b3c"> 1120</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPRNE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTNAKEN_EPRNE_SHIFT) &amp; USB_ENDPTNAKEN_EPRNE_MASK)</span></div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7e132b6e0f978508d429f5bc7c2f208e"> 1121</a></span><span class="preprocessor">#define USB_ENDPTNAKEN_EPRNE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTNAKEN_EPRNE_MASK) &gt;&gt; USB_ENDPTNAKEN_EPRNE_SHIFT)</span></div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span> </div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span><span class="comment">/* Bitfield definition for register: PORTSC1 */</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span><span class="comment">/*</span></div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span><span class="comment"> * STS (RW)</span></div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span><span class="comment"> *</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span><span class="comment"> * STS</span></div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span><span class="comment"> * Serial Transceiver Select</span></div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span><span class="comment"> * 1 Serial Interface Engine is selected</span></div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span><span class="comment"> * 0 Parallel Interface signals is selected</span></div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span><span class="comment"> * Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals.</span></div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span><span class="comment"> * When this bit is set &#39;1b&#39;, serial interface engine will be used instead of parallel interface signals.</span></div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span><span class="comment"> */</span></div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aabc4bb5c0b374e56641359cf8e83d480"> 1134</a></span><span class="preprocessor">#define USB_PORTSC1_STS_MASK (0x20000000UL)</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a029090a0437cd1d3ea8c0d19160747be"> 1135</a></span><span class="preprocessor">#define USB_PORTSC1_STS_SHIFT (29U)</span></div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a24a4df8b2dd7dcc6d201dc0b82cd10a1"> 1136</a></span><span class="preprocessor">#define USB_PORTSC1_STS_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_STS_SHIFT) &amp; USB_PORTSC1_STS_MASK)</span></div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af8a9c26022d3c9deffc46b6344eec957"> 1137</a></span><span class="preprocessor">#define USB_PORTSC1_STS_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_STS_MASK) &gt;&gt; USB_PORTSC1_STS_SHIFT)</span></div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span> </div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span><span class="comment">/*</span></div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="comment"> * PTW (RW)</span></div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span><span class="comment"> *</span></div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment"> * PTW</span></div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment"> * Parallel Transceiver Width</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span><span class="comment"> * This bit has no effect if serial interface engine is used.</span></div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span><span class="comment"> * 0 - Select the 8-bit UTMI interface [60MHz]</span></div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span><span class="comment"> * 1 - Select the 16-bit UTMI interface [30MHz]</span></div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span><span class="comment"> */</span></div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab50ddeedfe94abade62ebb14109e6f29"> 1148</a></span><span class="preprocessor">#define USB_PORTSC1_PTW_MASK (0x10000000UL)</span></div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab919d6afb66b0ccf9164331fe9b1b468"> 1149</a></span><span class="preprocessor">#define USB_PORTSC1_PTW_SHIFT (28U)</span></div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1d2d22c9d17f392b6af4b0d42af07a3c"> 1150</a></span><span class="preprocessor">#define USB_PORTSC1_PTW_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PTW_SHIFT) &amp; USB_PORTSC1_PTW_MASK)</span></div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af8f1226a61c62365cde2f42e3508ae01"> 1151</a></span><span class="preprocessor">#define USB_PORTSC1_PTW_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PTW_MASK) &gt;&gt; USB_PORTSC1_PTW_SHIFT)</span></div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span> </div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span><span class="comment">/*</span></div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span><span class="comment"> * PSPD (RO)</span></div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span><span class="comment"> *</span></div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span><span class="comment"> * PSPD</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span><span class="comment"> * Port Speed - Read Only.</span></div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span><span class="comment"> * This register field indicates the speed at which the port is operating.</span></div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span><span class="comment"> * 00 - Full Speed</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span><span class="comment"> * 01 - Low Speed</span></div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span><span class="comment"> * 10 - High Speed</span></div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span><span class="comment"> * 11 - Undefined</span></div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span><span class="comment"> */</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3381d1373ab9c991d3b17bd0dfe85074"> 1164</a></span><span class="preprocessor">#define USB_PORTSC1_PSPD_MASK (0xC000000UL)</span></div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6db4709fc10c1980b4c51c156aaf58c9"> 1165</a></span><span class="preprocessor">#define USB_PORTSC1_PSPD_SHIFT (26U)</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aaa9cb10d751a46365af5d3d8bc5442b4"> 1166</a></span><span class="preprocessor">#define USB_PORTSC1_PSPD_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PSPD_MASK) &gt;&gt; USB_PORTSC1_PSPD_SHIFT)</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span> </div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span><span class="comment">/*</span></div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment"> * PFSC (RW)</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span><span class="comment"> *</span></div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span><span class="comment"> * PFSC</span></div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="comment"> * Port Force Full Speed Connect - Read/Write. Default = 0b.</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span><span class="comment"> * When this bit is set to &#39;1b&#39;, the port will be forced to only connect at Full Speed, It disables the chirp</span></div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span><span class="comment"> * sequence that allows the port to identify itself as High Speed.</span></div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span><span class="comment"> * 0 - Normal operation</span></div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span><span class="comment"> * 1 - Forced to full speed</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span><span class="comment"> */</span></div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a668a254864c78eb99d297494efbb89fa"> 1178</a></span><span class="preprocessor">#define USB_PORTSC1_PFSC_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae0627c3ca4d8e3c3bf980c01c48b5db7"> 1179</a></span><span class="preprocessor">#define USB_PORTSC1_PFSC_SHIFT (24U)</span></div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7f6d32e27cc7ec85de354e2dd37edff0"> 1180</a></span><span class="preprocessor">#define USB_PORTSC1_PFSC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PFSC_SHIFT) &amp; USB_PORTSC1_PFSC_MASK)</span></div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a77b7d60f14bfda1c7a387d81be85d5a0"> 1181</a></span><span class="preprocessor">#define USB_PORTSC1_PFSC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PFSC_MASK) &gt;&gt; USB_PORTSC1_PFSC_SHIFT)</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span> </div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span><span class="comment">/*</span></div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span><span class="comment"> * PHCD (RW)</span></div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span><span class="comment"> *</span></div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span><span class="comment"> * PHCD</span></div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span><span class="comment"> * PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write. Default = 0b.</span></div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span><span class="comment"> * When this bit is set to &#39;1b&#39;, the PHY clock is disabled. Reading this bit will indicate the status of the PHY</span></div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span><span class="comment"> * clock.</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span><span class="comment"> * NOTE: The PHY clock cannot be disabled if it is being used as the system clock.</span></div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span><span class="comment"> * In device mode, The PHY can be put into Low Power Suspend when the device is not running (USBCMD</span></div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span><span class="comment"> * Run/Stop=0b) or the host has signalled suspend (PORTSC1 SUSPEND=1b). PHY Low power suspend</span></div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span><span class="comment"> * will be cleared automatically when the host initials resume. Before forcing a resume from the device, the</span></div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span><span class="comment"> * device controller driver must clear this bit.</span></div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span><span class="comment"> * In host mode, the PHY can be put into Low Power Suspend when the downstream device has been put</span></div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span><span class="comment"> * into suspend mode or when no downstream device is connected. Low power suspend is completely</span></div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span><span class="comment"> * under the control of software.</span></div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span><span class="comment"> * 0 - Enable PHY clock</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment"> * 1 - Disable PHY clock</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><span class="comment"> */</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a93daea760e825fafe4a6b38f1cd6b280"> 1201</a></span><span class="preprocessor">#define USB_PORTSC1_PHCD_MASK (0x800000UL)</span></div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa541732a446b491ad24357ee6869a283"> 1202</a></span><span class="preprocessor">#define USB_PORTSC1_PHCD_SHIFT (23U)</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1b2dbed958b74654bf1b2dd4f4106f68"> 1203</a></span><span class="preprocessor">#define USB_PORTSC1_PHCD_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PHCD_SHIFT) &amp; USB_PORTSC1_PHCD_MASK)</span></div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acd981aa2f6d1d38b5e920348b4255a3e"> 1204</a></span><span class="preprocessor">#define USB_PORTSC1_PHCD_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PHCD_MASK) &gt;&gt; USB_PORTSC1_PHCD_SHIFT)</span></div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span> </div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment">/*</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment"> * WKOC (RW)</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span><span class="comment"> *</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span><span class="comment"> * WKOC</span></div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span><span class="comment"> * Wake on Over-current Enable (WKOC_E) - Read/Write. Default = 0b.</span></div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment"> * Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events.</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero.</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span><span class="comment"> */</span></div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a42077d924a0585459081fc6fa7ae7906"> 1214</a></span><span class="preprocessor">#define USB_PORTSC1_WKOC_MASK (0x400000UL)</span></div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a772973d673e268ab1ab350d6d37cc79b"> 1215</a></span><span class="preprocessor">#define USB_PORTSC1_WKOC_SHIFT (22U)</span></div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac0cd78435ce02c980544f7f1ea7fb197"> 1216</a></span><span class="preprocessor">#define USB_PORTSC1_WKOC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_WKOC_SHIFT) &amp; USB_PORTSC1_WKOC_MASK)</span></div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0a5d13c258f617f315ed4d630fa07557"> 1217</a></span><span class="preprocessor">#define USB_PORTSC1_WKOC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_WKOC_MASK) &gt;&gt; USB_PORTSC1_WKOC_SHIFT)</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span> </div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span><span class="comment">/*</span></div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span><span class="comment"> * WKDC (RW)</span></div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span><span class="comment"> *</span></div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span><span class="comment"> * WKDC</span></div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span><span class="comment"> * Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write. Default=0b. Writing this bit to a one enables</span></div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span><span class="comment"> * the port to be sensitive to device disconnects as wake-up events.</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero or in device mode.</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span><span class="comment"> */</span></div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a92e6f93de2314046652ab2d2df22cfd8"> 1227</a></span><span class="preprocessor">#define USB_PORTSC1_WKDC_MASK (0x200000UL)</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a49e09039cc8e2cc6fc6625b5b2c1d4de"> 1228</a></span><span class="preprocessor">#define USB_PORTSC1_WKDC_SHIFT (21U)</span></div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1c7dc91cf6a1fcf243223aaa7734f5ba"> 1229</a></span><span class="preprocessor">#define USB_PORTSC1_WKDC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_WKDC_SHIFT) &amp; USB_PORTSC1_WKDC_MASK)</span></div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af9c12a3c4cbb2b0956b0412e46013aa8"> 1230</a></span><span class="preprocessor">#define USB_PORTSC1_WKDC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_WKDC_MASK) &gt;&gt; USB_PORTSC1_WKDC_SHIFT)</span></div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span> </div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span><span class="comment">/*</span></div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span><span class="comment"> * WKCN (RW)</span></div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span><span class="comment"> *</span></div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span><span class="comment"> * WKCN</span></div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span><span class="comment"> * Wake on Connect Enable (WKCNNT_E) - Read/Write. Default=0b.</span></div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span><span class="comment"> * Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.</span></div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero or in device mode.</span></div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span><span class="comment"> */</span></div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af0c726a66c80b116a8524559cc62eca2"> 1240</a></span><span class="preprocessor">#define USB_PORTSC1_WKCN_MASK (0x100000UL)</span></div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a96ae69e92fcebb26f05a28c9f8899569"> 1241</a></span><span class="preprocessor">#define USB_PORTSC1_WKCN_SHIFT (20U)</span></div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a22175156220c3b220a5e0917b0ef6280"> 1242</a></span><span class="preprocessor">#define USB_PORTSC1_WKCN_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_WKCN_SHIFT) &amp; USB_PORTSC1_WKCN_MASK)</span></div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a38612249439006b3d6bac751d8dd2e69"> 1243</a></span><span class="preprocessor">#define USB_PORTSC1_WKCN_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_WKCN_MASK) &gt;&gt; USB_PORTSC1_WKCN_SHIFT)</span></div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span> </div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span><span class="comment">/*</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span><span class="comment"> * PTC (RW)</span></div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span><span class="comment"> *</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span><span class="comment"> * PTC</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span><span class="comment"> * Port Test Control - Read/Write. Default = 0000b.</span></div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span><span class="comment"> * Refer to Port Test Mode for the operational model for using these test modes and the USB Specification Revision 2.0, Chapter 7 for details on each test mode.</span></div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span><span class="comment"> * The FORCE_ENABLE_FS and FORCE ENABLE_LS are extensions to the test mode support specified in the EHCI specification.</span></div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span><span class="comment"> * Writing the PTC field to any of the FORCE_ENABLE_{HS/FS/LS} values will force the port into the connected and enabled state at the selected speed.</span></div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span><span class="comment"> * Writing the PTC field back to TEST_MODE_DISABLE will allow the port state machines to progress normally from that point.</span></div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="comment"> * NOTE: Low speed operations are not supported as a peripheral device.</span></div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span><span class="comment"> * Any other value than zero indicates that the port is operating in test mode.</span></div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span><span class="comment"> * Value Specific Test</span></div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span><span class="comment"> * 0000 - TEST_MODE_DISABLE</span></div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="comment"> * 0001 - J_STATE</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span><span class="comment"> * 0010 - K_STATE</span></div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span><span class="comment"> * 0011 - SE0 (host) / NAK (device)</span></div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span><span class="comment"> * 0100 - Packet</span></div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span><span class="comment"> * 0101 - FORCE_ENABLE_HS</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span><span class="comment"> * 0110 - FORCE_ENABLE_FS</span></div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span><span class="comment"> * 0111 - FORCE_ENABLE_LS</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span><span class="comment"> * 1000-1111 - Reserved</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span><span class="comment"> */</span></div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a937711f032fc6276b3502e5217497aec"> 1267</a></span><span class="preprocessor">#define USB_PORTSC1_PTC_MASK (0xF0000UL)</span></div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aab2810736241fbe5a28759ff9e37c8d2"> 1268</a></span><span class="preprocessor">#define USB_PORTSC1_PTC_SHIFT (16U)</span></div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8fb62460b20e9eabbfd937e3b7124108"> 1269</a></span><span class="preprocessor">#define USB_PORTSC1_PTC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PTC_SHIFT) &amp; USB_PORTSC1_PTC_MASK)</span></div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad26d5134535d5941197837890b3abf00"> 1270</a></span><span class="preprocessor">#define USB_PORTSC1_PTC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PTC_MASK) &gt;&gt; USB_PORTSC1_PTC_SHIFT)</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span> </div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span><span class="comment">/*</span></div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span><span class="comment"> * PP (RW)</span></div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span><span class="comment"> *</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span><span class="comment"> * PP</span></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span><span class="comment"> * Port Power (PP)-Read/Write or Read Only.</span></div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span><span class="comment"> * The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:</span></div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span><span class="comment"> * PPC</span></div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span><span class="comment"> * PP Operation</span></div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span><span class="comment"> * 0</span></div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span><span class="comment"> * 1b Read Only - Host controller does not have port power control switches. Each port is hard-wired to power.</span></div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span><span class="comment"> * 1</span></div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span><span class="comment"> * 1b/0b - Read/Write. OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on).</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span><span class="comment"> * When power is not available on a port (that is, PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span><span class="comment"> * When an over-current condition is detected on a powered port and PPC is a one,</span></div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span><span class="comment"> * the PP bit in each affected port may be transitional by the host controller driver from a one to a zero (removing power from the port).</span></div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span><span class="comment"> * This feature is implemented in all controller cores (PPC = 1).</span></div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span><span class="comment"> */</span></div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8f2fa86b9c41ae6f21cd17920c3b27da"> 1289</a></span><span class="preprocessor">#define USB_PORTSC1_PP_MASK (0x1000U)</span></div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a589187538362111b758315a3ed3858c1"> 1290</a></span><span class="preprocessor">#define USB_PORTSC1_PP_SHIFT (12U)</span></div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afc25b4f762bbb14742a33bf6f9c34644"> 1291</a></span><span class="preprocessor">#define USB_PORTSC1_PP_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PP_SHIFT) &amp; USB_PORTSC1_PP_MASK)</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afbb8943da5cc6b4eda95eba184af4b69"> 1292</a></span><span class="preprocessor">#define USB_PORTSC1_PP_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PP_MASK) &gt;&gt; USB_PORTSC1_PP_SHIFT)</span></div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span> </div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span><span class="comment">/*</span></div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span><span class="comment"> * LS (RO)</span></div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span><span class="comment"> *</span></div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span><span class="comment"> * LS</span></div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span><span class="comment"> * Line Status-Read Only. These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span><span class="comment"> * lines.</span></div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span><span class="comment"> * In host mode, the use of linestate by the host controller driver is not necessary (unlike EHCI), because</span></div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span><span class="comment"> * the port controller state machine and the port routing manage the connection of LS and FS.</span></div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span><span class="comment"> * In device mode, the use of linestate by the device controller driver is not necessary.</span></div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span><span class="comment"> * The encoding of the bits are:</span></div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span><span class="comment"> * Bits [11:10] Meaning</span></div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span><span class="comment"> * 00 - SE0</span></div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span><span class="comment"> * 01 - K-state</span></div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span><span class="comment"> * 10 - J-state</span></div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span><span class="comment"> * 11 - Undefined</span></div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span><span class="comment"> */</span></div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5b8e146076d3eeb8b842d92ff95ff62a"> 1310</a></span><span class="preprocessor">#define USB_PORTSC1_LS_MASK (0xC00U)</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a467fe0f9ba31972b2d894edefba21c25"> 1311</a></span><span class="preprocessor">#define USB_PORTSC1_LS_SHIFT (10U)</span></div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae8d765adbeb5c14f51005a4ba06d08b6"> 1312</a></span><span class="preprocessor">#define USB_PORTSC1_LS_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_LS_MASK) &gt;&gt; USB_PORTSC1_LS_SHIFT)</span></div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span> </div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span><span class="comment">/*</span></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span><span class="comment"> * HSP (RO)</span></div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span><span class="comment"> *</span></div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span><span class="comment"> * HSP</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span><span class="comment"> * High-Speed Port - Read Only. Default = 0b.</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span><span class="comment"> * When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the</span></div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span><span class="comment"> * host/device connected to the port is not in a high-speed mode.</span></div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span><span class="comment"> * NOTE: HSP is redundant with PSPD(bit 27, 26) but remained for compatibility.</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment"> */</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a04ee074bb9a1dfb36d74af32dd315c42"> 1323</a></span><span class="preprocessor">#define USB_PORTSC1_HSP_MASK (0x200U)</span></div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae30d80387e601483bf4f58cae7d709d0"> 1324</a></span><span class="preprocessor">#define USB_PORTSC1_HSP_SHIFT (9U)</span></div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8ce35f6ef08676a4233c64501b1647d0"> 1325</a></span><span class="preprocessor">#define USB_PORTSC1_HSP_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_HSP_MASK) &gt;&gt; USB_PORTSC1_HSP_SHIFT)</span></div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span> </div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span><span class="comment">/*</span></div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment"> * PR (RW)</span></div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="comment"> *</span></div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span><span class="comment"> * PR</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span><span class="comment"> * Port Reset - Read/Write or Read Only. Default = 0b.</span></div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="comment"> * In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. Default 0.</span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span><span class="comment"> * When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started.</span></div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="comment"> * This bit will automatically change to zero after the reset sequence is complete.</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span><span class="comment"> * This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.</span></div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="comment"> * In Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register.</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span><span class="comment"> */</span></div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af4a5168722b2d190db1ed29f77046859"> 1338</a></span><span class="preprocessor">#define USB_PORTSC1_PR_MASK (0x100U)</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afb12b35d86d807a13402a04ed9f84c4a"> 1339</a></span><span class="preprocessor">#define USB_PORTSC1_PR_SHIFT (8U)</span></div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9218547404f9f9e2adadc922e21d922e"> 1340</a></span><span class="preprocessor">#define USB_PORTSC1_PR_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PR_SHIFT) &amp; USB_PORTSC1_PR_MASK)</span></div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af0c91d533d30908cb2bb80a7bd7fb626"> 1341</a></span><span class="preprocessor">#define USB_PORTSC1_PR_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PR_MASK) &gt;&gt; USB_PORTSC1_PR_SHIFT)</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span> </div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span><span class="comment">/*</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span><span class="comment"> * SUSP (RW)</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span><span class="comment"> *</span></div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span><span class="comment"> * SUSP</span></div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span><span class="comment"> * Suspend - Read/Write or Read Only. Default = 0b.</span></div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span><span class="comment"> * 1=Port in suspend state. 0=Port not in suspend state.</span></div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="comment"> * In Host Mode: Read/Write.</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span><span class="comment"> * Port Enabled Bit and Suspend bit of this register define the port states as follows:</span></div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span><span class="comment"> * Bits [Port Enabled, Suspend] Port State</span></div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span><span class="comment"> * 0x Disable</span></div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span><span class="comment"> * 10 Enable</span></div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span><span class="comment"> * 11 Suspend</span></div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span><span class="comment"> * When in suspend state, downstream propagation of data is blocked on this port, except for port reset.</span></div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span><span class="comment"> * The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1.</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span><span class="comment"> * In the suspend state, the port is sensitive to resume detection.</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span><span class="comment"> * Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span><span class="comment"> * The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. The host controller ignores a write of zero to this bit.</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment"> * If host software sets this bit to a one when the port is not enabled (that is, Port enabled bit is a zero) the results are undefined.</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero in host mode.</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span><span class="comment"> * In Device Mode: Read Only.</span></div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span><span class="comment"> * In device mode this bit is a read only status bit.</span></div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span><span class="comment"> */</span></div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aed104d1557260f47cae18bb08793f10e"> 1365</a></span><span class="preprocessor">#define USB_PORTSC1_SUSP_MASK (0x80U)</span></div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#addc770ebe01869f68783176a9820c6e7"> 1366</a></span><span class="preprocessor">#define USB_PORTSC1_SUSP_SHIFT (7U)</span></div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a06c7e0f08c80ac8c84a13a2ec3e56b1d"> 1367</a></span><span class="preprocessor">#define USB_PORTSC1_SUSP_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_SUSP_SHIFT) &amp; USB_PORTSC1_SUSP_MASK)</span></div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af904d6f961fb5c82bbcbb41179dbee7f"> 1368</a></span><span class="preprocessor">#define USB_PORTSC1_SUSP_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_SUSP_MASK) &gt;&gt; USB_PORTSC1_SUSP_SHIFT)</span></div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span> </div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span><span class="comment">/*</span></div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span><span class="comment"> * FPR (RW)</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span><span class="comment"> *</span></div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span><span class="comment"> * FPR</span></div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span><span class="comment"> * Force Port Resume -Read/Write. 1= Resume detected/driven on port. 0=No resume (K-state) detected driven on port. Default = 0.</span></div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span><span class="comment"> * In Host Mode:</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span><span class="comment"> * Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state.</span></div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span><span class="comment"> * When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.</span></div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span><span class="comment"> * This bit will automatically change to zero after the resume sequence is complete.</span></div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span><span class="comment"> * This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span><span class="comment"> * Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0.</span></div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span><span class="comment"> * The resume signaling (Full-speed &#39;K&#39;) is driven on the port as long as this bit remains a one. This bit will remain a one until the port has switched to the high-speed idle.</span></div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span><span class="comment"> * Writing a zero has no effect because the port controller will time the resume operation, clear the bit the port control state switches to HS or FS idle.</span></div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero in host mode.</span></div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span><span class="comment"> * This bit is not-EHCI compatible.</span></div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span><span class="comment"> * In Device mode:</span></div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span><span class="comment"> * After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing.</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span><span class="comment"> * The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state.</span></div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span><span class="comment"> * The bit will be cleared when the device returns to normal operation.</span></div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span><span class="comment"> *  Also, when this bit wil be cleared because a K-to-J transition detected, the Port Change Detect bit in the USBSTS register is also set to one.</span></div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span><span class="comment"> */</span></div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa27da1f234ff08a245eff05f06f1162c"> 1391</a></span><span class="preprocessor">#define USB_PORTSC1_FPR_MASK (0x40U)</span></div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acd4e19ac764488f33bd0e1a791bb30c4"> 1392</a></span><span class="preprocessor">#define USB_PORTSC1_FPR_SHIFT (6U)</span></div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9b66d5f7cbb4a726bb50a55f29e79ed8"> 1393</a></span><span class="preprocessor">#define USB_PORTSC1_FPR_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_FPR_SHIFT) &amp; USB_PORTSC1_FPR_MASK)</span></div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a409e1ff1fe0037317191086100092422"> 1394</a></span><span class="preprocessor">#define USB_PORTSC1_FPR_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_FPR_MASK) &gt;&gt; USB_PORTSC1_FPR_SHIFT)</span></div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span> </div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span><span class="comment">/*</span></div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span><span class="comment"> * OCC (RW)</span></div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span><span class="comment"> *</span></div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span><span class="comment"> * OCC</span></div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span><span class="comment"> * Over-current Change-R/WC. Default=0.</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span><span class="comment"> * This bit is set &#39;1b&#39; by hardware when there is a change to Over-current Active. Software can clear this bit by writing a one to this bit position.</span></div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span><span class="comment"> */</span></div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae980f6817a95b9b2db525abe075b2756"> 1403</a></span><span class="preprocessor">#define USB_PORTSC1_OCC_MASK (0x20U)</span></div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abe7d3456da2019c4daf4336ebaceace0"> 1404</a></span><span class="preprocessor">#define USB_PORTSC1_OCC_SHIFT (5U)</span></div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aed88aa84f01aca9735226a5bc5d03a2b"> 1405</a></span><span class="preprocessor">#define USB_PORTSC1_OCC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_OCC_SHIFT) &amp; USB_PORTSC1_OCC_MASK)</span></div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a911fa5f0b4d6d0f632a89830631c2d6e"> 1406</a></span><span class="preprocessor">#define USB_PORTSC1_OCC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_OCC_MASK) &gt;&gt; USB_PORTSC1_OCC_SHIFT)</span></div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span> </div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span><span class="comment">/*</span></div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span><span class="comment"> * OCA (RO)</span></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span><span class="comment"> *</span></div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span><span class="comment"> * OCA</span></div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span><span class="comment"> * Over-current Active-Read Only. Default 0.</span></div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span><span class="comment"> * This bit will automatically transition from one to zero when the over current condition is removed.</span></div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span><span class="comment"> * 0 - This port does not have an over-current condition.</span></div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span><span class="comment"> * 1 - This port currently has an over-current condition</span></div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span><span class="comment"> */</span></div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aed30f7428d1d8ce0fd94e3015583b3f9"> 1417</a></span><span class="preprocessor">#define USB_PORTSC1_OCA_MASK (0x10U)</span></div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adc3f5d432c93b28ce1c59fe56a218193"> 1418</a></span><span class="preprocessor">#define USB_PORTSC1_OCA_SHIFT (4U)</span></div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3f51c0815166996a1e15496a0334ec74"> 1419</a></span><span class="preprocessor">#define USB_PORTSC1_OCA_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_OCA_MASK) &gt;&gt; USB_PORTSC1_OCA_SHIFT)</span></div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span> </div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span><span class="comment">/*</span></div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span><span class="comment"> * PEC (RWC)</span></div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span><span class="comment"> *</span></div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span><span class="comment"> * PEC</span></div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span><span class="comment"> * Port Enable/Disable Change-R/WC. 1=Port enabled/disabled status has changed. 0=No change. Default = 0.</span></div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span><span class="comment"> * In Host Mode:</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span><span class="comment"> * For the root hub, this bit is set to a one only when a port is disabled due to disconnect on the port or</span></div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span><span class="comment"> * due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification).</span></div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span><span class="comment"> * Software clears this by writing a one to it.</span></div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero.</span></div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span><span class="comment"> * In Device mode:</span></div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span><span class="comment"> * The device port is always enabled, so this bit is always &#39;0b&#39;.</span></div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span><span class="comment"> */</span></div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1efbb0dfff4ee885979f00b06d55b86d"> 1434</a></span><span class="preprocessor">#define USB_PORTSC1_PEC_MASK (0x8U)</span></div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad8cbdbcc739f43a6ae287c9ea5237dd7"> 1435</a></span><span class="preprocessor">#define USB_PORTSC1_PEC_SHIFT (3U)</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad1ef5b42b437bd5669165317a7eb2b03"> 1436</a></span><span class="preprocessor">#define USB_PORTSC1_PEC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PEC_SHIFT) &amp; USB_PORTSC1_PEC_MASK)</span></div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8bfa1b519a9dd05d385eb40cfb4be758"> 1437</a></span><span class="preprocessor">#define USB_PORTSC1_PEC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PEC_MASK) &gt;&gt; USB_PORTSC1_PEC_SHIFT)</span></div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span> </div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span><span class="comment">/*</span></div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span><span class="comment"> * PE (RWC)</span></div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span><span class="comment"> *</span></div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span><span class="comment"> * PE</span></div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span><span class="comment"> * Port Enabled/Disabled-Read/Write. 1=Enable. 0=Disable. Default 0.</span></div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span><span class="comment"> * In Host Mode:</span></div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span><span class="comment"> * Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field.</span></div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span><span class="comment"> * Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software.</span></div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span><span class="comment"> * Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span><span class="comment"> * When the port is disabled, (0b) downstream propagation of data is blocked except for reset.</span></div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero in host mode.</span></div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span><span class="comment"> * In Device Mode:</span></div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span><span class="comment"> * The device port is always enabled, so this bit is always &#39;1b&#39;.</span></div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span><span class="comment"> */</span></div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a49f3b096f830911a8183c6abf7b9ec02"> 1453</a></span><span class="preprocessor">#define USB_PORTSC1_PE_MASK (0x4U)</span></div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab7c36cf81d79a8135d37a7387b410053"> 1454</a></span><span class="preprocessor">#define USB_PORTSC1_PE_SHIFT (2U)</span></div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac64ee3336e5083e49e219cfd79d1cb7e"> 1455</a></span><span class="preprocessor">#define USB_PORTSC1_PE_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_PE_SHIFT) &amp; USB_PORTSC1_PE_MASK)</span></div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae17b294162620adc63a530b9fd632529"> 1456</a></span><span class="preprocessor">#define USB_PORTSC1_PE_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_PE_MASK) &gt;&gt; USB_PORTSC1_PE_SHIFT)</span></div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span> </div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span><span class="comment">/*</span></div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span><span class="comment"> * CSC (RWC)</span></div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span><span class="comment"> *</span></div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span><span class="comment"> * CSC</span></div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span><span class="comment"> * Connect Status Change-R/WC. 1 =Change in Current Connect Status. 0=No change. Default 0.</span></div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span><span class="comment"> * In Host Mode:</span></div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span><span class="comment"> * Indicates a change has occurred in the port&#39;s Current Connect Status.</span></div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span><span class="comment"> * The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change.</span></div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span><span class="comment"> * For example, the insertion status changes twice before system software has cleared the changed condition,</span></div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span><span class="comment"> * hub hardware will be &#39;setting&#39; an already-set bit (that is, the bit will remain set). Software clears this bit by writing a one to it.</span></div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero in host mode.</span></div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span><span class="comment"> * In Device Mode:</span></div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span><span class="comment"> * This bit is undefined in device controller mode.</span></div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span><span class="comment"> */</span></div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0cbd2eb91d778426721e2bdc14913f7d"> 1472</a></span><span class="preprocessor">#define USB_PORTSC1_CSC_MASK (0x2U)</span></div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac0f2c4a2b962d65687b5b8bb3a109c29"> 1473</a></span><span class="preprocessor">#define USB_PORTSC1_CSC_SHIFT (1U)</span></div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8a5e798320321134651eaaf0e52d8f7d"> 1474</a></span><span class="preprocessor">#define USB_PORTSC1_CSC_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_CSC_SHIFT) &amp; USB_PORTSC1_CSC_MASK)</span></div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0347f7939fb70744bfcb69a952748210"> 1475</a></span><span class="preprocessor">#define USB_PORTSC1_CSC_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_CSC_MASK) &gt;&gt; USB_PORTSC1_CSC_SHIFT)</span></div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span> </div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span><span class="comment">/*</span></div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span><span class="comment"> * CCS (RWC)</span></div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span><span class="comment"> *</span></div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span><span class="comment"> * CCS</span></div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span><span class="comment"> * Current Connect Status-Read Only.</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span><span class="comment"> * In Host Mode:</span></div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span><span class="comment"> * 1=Device is present on port. 0=No device is present. Default = 0.</span></div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span><span class="comment"> * This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set.</span></div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span><span class="comment"> * This field is zero if Port Power(PORTSC1) is zero in host mode.</span></div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span><span class="comment"> * In Device Mode:</span></div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span><span class="comment"> * 1=Attached. 0=Not Attached. Default=0.</span></div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span><span class="comment"> * A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register.</span></div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span><span class="comment"> * A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register.</span></div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"> 1490</span><span class="comment"> * It does not state the device being disconnected or Suspended.</span></div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span><span class="comment"> */</span></div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa30092f215fc72c6970d3eddac015861"> 1492</a></span><span class="preprocessor">#define USB_PORTSC1_CCS_MASK (0x1U)</span></div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aed003e542f1f8f7668ed9f459e6603b0"> 1493</a></span><span class="preprocessor">#define USB_PORTSC1_CCS_SHIFT (0U)</span></div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2c4ffe2d04db3d120a85329f2a62556c"> 1494</a></span><span class="preprocessor">#define USB_PORTSC1_CCS_SET(x) (((uint32_t)(x) &lt;&lt; USB_PORTSC1_CCS_SHIFT) &amp; USB_PORTSC1_CCS_MASK)</span></div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a18a37c667ed945528303451c44bc357c"> 1495</a></span><span class="preprocessor">#define USB_PORTSC1_CCS_GET(x) (((uint32_t)(x) &amp; USB_PORTSC1_CCS_MASK) &gt;&gt; USB_PORTSC1_CCS_SHIFT)</span></div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"> 1496</span> </div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span><span class="comment">/* Bitfield definition for register: OTGSC */</span></div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span><span class="comment">/*</span></div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span><span class="comment"> * ASVIE (RW)</span></div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span><span class="comment"> *</span></div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span><span class="comment"> * ASVIE</span></div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"> 1502</span><span class="comment"> * A Session Valid Interrupt Enable - Read/Write.</span></div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span><span class="comment"> */</span></div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5ddfe78497554a746d69933394135c32"> 1504</a></span><span class="preprocessor">#define USB_OTGSC_ASVIE_MASK (0x4000000UL)</span></div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8c1a6a33998ae911410b18ad78252da3"> 1505</a></span><span class="preprocessor">#define USB_OTGSC_ASVIE_SHIFT (26U)</span></div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afd72140eaafe743ed06df7af7306d242"> 1506</a></span><span class="preprocessor">#define USB_OTGSC_ASVIE_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_ASVIE_SHIFT) &amp; USB_OTGSC_ASVIE_MASK)</span></div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a11d8e34e5fc9c04273b7bf8c8f265e73"> 1507</a></span><span class="preprocessor">#define USB_OTGSC_ASVIE_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_ASVIE_MASK) &gt;&gt; USB_OTGSC_ASVIE_SHIFT)</span></div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"> 1508</span> </div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span><span class="comment">/*</span></div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span><span class="comment"> * AVVIE (RW)</span></div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span><span class="comment"> *</span></div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span><span class="comment"> * AVVIE</span></div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span><span class="comment"> * A VBus Valid Interrupt Enable - Read/Write.</span></div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span><span class="comment"> * Setting this bit enables the A VBus valid interrupt.</span></div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span><span class="comment"> */</span></div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad808b694afa62cff8704cd34374a2120"> 1516</a></span><span class="preprocessor">#define USB_OTGSC_AVVIE_MASK (0x2000000UL)</span></div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a27a58d9d8f9e17299c1fd7186ff6a5d0"> 1517</a></span><span class="preprocessor">#define USB_OTGSC_AVVIE_SHIFT (25U)</span></div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5d95cbd80d8fac02d24b0c98a21a60a8"> 1518</a></span><span class="preprocessor">#define USB_OTGSC_AVVIE_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_AVVIE_SHIFT) &amp; USB_OTGSC_AVVIE_MASK)</span></div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a557844526fe683e1afe784aca544005c"> 1519</a></span><span class="preprocessor">#define USB_OTGSC_AVVIE_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_AVVIE_MASK) &gt;&gt; USB_OTGSC_AVVIE_SHIFT)</span></div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span> </div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span><span class="comment">/*</span></div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span><span class="comment"> * IDIE (RW)</span></div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span><span class="comment"> *</span></div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span><span class="comment"> * IDIE</span></div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span><span class="comment"> * USB ID Interrupt Enable - Read/Write.</span></div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span><span class="comment"> * Setting this bit enables the USB ID interrupt.</span></div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span><span class="comment"> */</span></div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aff9f8f5b130e17e0e3f383959bfbc63e"> 1528</a></span><span class="preprocessor">#define USB_OTGSC_IDIE_MASK (0x1000000UL)</span></div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a35c43ee8f5904325f119ff7dd0221a27"> 1529</a></span><span class="preprocessor">#define USB_OTGSC_IDIE_SHIFT (24U)</span></div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a615dbcb3471da10166c1b4d9dd214bb9"> 1530</a></span><span class="preprocessor">#define USB_OTGSC_IDIE_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_IDIE_SHIFT) &amp; USB_OTGSC_IDIE_MASK)</span></div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aae323d59d23e2309e498059ce133a15a"> 1531</a></span><span class="preprocessor">#define USB_OTGSC_IDIE_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_IDIE_MASK) &gt;&gt; USB_OTGSC_IDIE_SHIFT)</span></div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span> </div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span><span class="comment">/*</span></div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span><span class="comment"> * ASVIS (RWC)</span></div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span><span class="comment"> *</span></div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span><span class="comment"> * ASVIS</span></div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span><span class="comment"> * A Session Valid Interrupt Status - Read/Write to Clear.</span></div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span><span class="comment"> * This bit is set when VBus has either risen above or fallen below the A session valid threshold.</span></div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span><span class="comment"> * Software must write a one to clear this bit.</span></div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"> 1540</span><span class="comment"> */</span></div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a48e142c4cffafdb720fed76d0e610b3a"> 1541</a></span><span class="preprocessor">#define USB_OTGSC_ASVIS_MASK (0x40000UL)</span></div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5da4ffc37d09cde601b2dd90b15854da"> 1542</a></span><span class="preprocessor">#define USB_OTGSC_ASVIS_SHIFT (18U)</span></div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a82ca41df98523dcf9898a5f57bca9239"> 1543</a></span><span class="preprocessor">#define USB_OTGSC_ASVIS_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_ASVIS_SHIFT) &amp; USB_OTGSC_ASVIS_MASK)</span></div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1ffb2bd420f25e195819248058b4c51c"> 1544</a></span><span class="preprocessor">#define USB_OTGSC_ASVIS_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_ASVIS_MASK) &gt;&gt; USB_OTGSC_ASVIS_SHIFT)</span></div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span> </div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"> 1546</span><span class="comment">/*</span></div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span><span class="comment"> * AVVIS (RWC)</span></div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span><span class="comment"> *</span></div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span><span class="comment"> * AVVIS</span></div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span><span class="comment"> * A VBus Valid Interrupt Status - Read/Write to Clear.</span></div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span><span class="comment"> * This bit is set when VBus has either risen above or fallen below the VBus valid threshold on an A device.</span></div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span><span class="comment"> * Software must write a one to clear this bit.</span></div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span><span class="comment"> */</span></div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a564a5c6fbb6c67451f6018e9da4e276d"> 1554</a></span><span class="preprocessor">#define USB_OTGSC_AVVIS_MASK (0x20000UL)</span></div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7e5ab950811f89fca5f7e46e33d9d6ac"> 1555</a></span><span class="preprocessor">#define USB_OTGSC_AVVIS_SHIFT (17U)</span></div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a27c47d3790a7f1d2a8d6487c8a449ca4"> 1556</a></span><span class="preprocessor">#define USB_OTGSC_AVVIS_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_AVVIS_SHIFT) &amp; USB_OTGSC_AVVIS_MASK)</span></div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa51de26cc176325064794ce9554d30ca"> 1557</a></span><span class="preprocessor">#define USB_OTGSC_AVVIS_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_AVVIS_MASK) &gt;&gt; USB_OTGSC_AVVIS_SHIFT)</span></div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"> 1558</span> </div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span><span class="comment">/*</span></div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span><span class="comment"> * IDIS (RWC)</span></div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span><span class="comment"> *</span></div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span><span class="comment"> * IDIS</span></div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span><span class="comment"> * USB ID Interrupt Status - Read/Write.</span></div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span><span class="comment"> * This bit is set when a change on the ID input has been detected.</span></div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"> 1565</span><span class="comment"> * Software must write a one to clear this bit.</span></div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"> 1566</span><span class="comment"> */</span></div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8dda6ba39a6b9dd5214ce662e7cabbb7"> 1567</a></span><span class="preprocessor">#define USB_OTGSC_IDIS_MASK (0x10000UL)</span></div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8d92e42803629341f26a45bfafb21d8b"> 1568</a></span><span class="preprocessor">#define USB_OTGSC_IDIS_SHIFT (16U)</span></div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af0692112362976cfb61e919e0238c800"> 1569</a></span><span class="preprocessor">#define USB_OTGSC_IDIS_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_IDIS_SHIFT) &amp; USB_OTGSC_IDIS_MASK)</span></div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a842c4da4862c8e650416b8262596fc4d"> 1570</a></span><span class="preprocessor">#define USB_OTGSC_IDIS_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_IDIS_MASK) &gt;&gt; USB_OTGSC_IDIS_SHIFT)</span></div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span> </div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span><span class="comment">/*</span></div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span><span class="comment"> * ASV (RO)</span></div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span><span class="comment"> *</span></div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span><span class="comment"> * ASV</span></div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span><span class="comment"> * A Session Valid - Read Only.</span></div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"> 1577</span><span class="comment"> * Indicates VBus is above the A session valid threshold.</span></div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span><span class="comment"> */</span></div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aeaf6129865104deba6748cff9abd46c2"> 1579</a></span><span class="preprocessor">#define USB_OTGSC_ASV_MASK (0x400U)</span></div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa4c0bcf4453f758cb17531ccd1b6f20d"> 1580</a></span><span class="preprocessor">#define USB_OTGSC_ASV_SHIFT (10U)</span></div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a90e0c9b966246e091f65b85387ffe31f"> 1581</a></span><span class="preprocessor">#define USB_OTGSC_ASV_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_ASV_MASK) &gt;&gt; USB_OTGSC_ASV_SHIFT)</span></div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span> </div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span><span class="comment">/*</span></div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span><span class="comment"> * AVV (RO)</span></div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span><span class="comment"> *</span></div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span><span class="comment"> * AVV</span></div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span><span class="comment"> * A VBus Valid - Read Only.</span></div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span><span class="comment"> * Indicates VBus is above the A VBus valid threshold.</span></div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span><span class="comment"> */</span></div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1f1a24d5fff2d140f3340d144e3cccf4"> 1590</a></span><span class="preprocessor">#define USB_OTGSC_AVV_MASK (0x200U)</span></div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af2bd9ced186c17353f247c2abbbb8d06"> 1591</a></span><span class="preprocessor">#define USB_OTGSC_AVV_SHIFT (9U)</span></div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abcdca6ed1e1042ddb7d0ed612f595d55"> 1592</a></span><span class="preprocessor">#define USB_OTGSC_AVV_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_AVV_MASK) &gt;&gt; USB_OTGSC_AVV_SHIFT)</span></div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span> </div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span><span class="comment">/*</span></div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span><span class="comment"> * ID (RO)</span></div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span><span class="comment"> *</span></div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span><span class="comment"> * ID</span></div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span><span class="comment"> * USB ID - Read Only.</span></div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span><span class="comment"> * 0 = A device, 1 = B device</span></div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span><span class="comment"> */</span></div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a95800f3d595ead19b8cf53b359278fa4"> 1601</a></span><span class="preprocessor">#define USB_OTGSC_ID_MASK (0x100U)</span></div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5ca2e072dc9622a0c0ade185931424b2"> 1602</a></span><span class="preprocessor">#define USB_OTGSC_ID_SHIFT (8U)</span></div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5a81d7b4dbe24654247d5d0a355d823e"> 1603</a></span><span class="preprocessor">#define USB_OTGSC_ID_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_ID_MASK) &gt;&gt; USB_OTGSC_ID_SHIFT)</span></div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span> </div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span><span class="comment">/*</span></div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span><span class="comment"> * IDPU (RW)</span></div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span><span class="comment"> *</span></div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span><span class="comment"> * IDPU</span></div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span><span class="comment"> * ID Pullup - Read/Write</span></div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"> 1610</span><span class="comment"> * This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]. When this bit is 0, the ID input</span></div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span><span class="comment"> * will not be sampled.</span></div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span><span class="comment"> */</span></div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a153c312deba1c7cae3e55d03ea1be748"> 1613</a></span><span class="preprocessor">#define USB_OTGSC_IDPU_MASK (0x20U)</span></div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a68432ab586717905bb45ca5e0058215c"> 1614</a></span><span class="preprocessor">#define USB_OTGSC_IDPU_SHIFT (5U)</span></div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a63b4a13847670cc65a3055007ca13222"> 1615</a></span><span class="preprocessor">#define USB_OTGSC_IDPU_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_IDPU_SHIFT) &amp; USB_OTGSC_IDPU_MASK)</span></div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aae713fdcc9d43205d0760a4733b745b2"> 1616</a></span><span class="preprocessor">#define USB_OTGSC_IDPU_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_IDPU_MASK) &gt;&gt; USB_OTGSC_IDPU_SHIFT)</span></div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span> </div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span><span class="comment">/*</span></div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span><span class="comment"> * VC (RW)</span></div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span><span class="comment"> *</span></div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span><span class="comment"> * VC</span></div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span><span class="comment"> * VBUS Charge - Read/Write.</span></div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span><span class="comment"> * Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</span></div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span><span class="comment"> */</span></div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad3585b4987e91be360e099e7b21c2da2"> 1625</a></span><span class="preprocessor">#define USB_OTGSC_VC_MASK (0x2U)</span></div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a82b8c81556f25d61821fd4801a99be8d"> 1626</a></span><span class="preprocessor">#define USB_OTGSC_VC_SHIFT (1U)</span></div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a35f47a0a0391ac70a13a5675b43e211e"> 1627</a></span><span class="preprocessor">#define USB_OTGSC_VC_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_VC_SHIFT) &amp; USB_OTGSC_VC_MASK)</span></div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a49321e0ff3d23216d7d264bb4502c825"> 1628</a></span><span class="preprocessor">#define USB_OTGSC_VC_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_VC_MASK) &gt;&gt; USB_OTGSC_VC_SHIFT)</span></div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"> 1629</span> </div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span><span class="comment">/*</span></div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span><span class="comment"> * VD (RW)</span></div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span><span class="comment"> *</span></div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span><span class="comment"> * VD</span></div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span><span class="comment"> * VBUS_Discharge - Read/Write.</span></div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span><span class="comment"> * Setting this bit causes VBus to discharge through a resistor.</span></div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span><span class="comment"> */</span></div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a481b90b441d9f9c92cb23ee08e3c884d"> 1637</a></span><span class="preprocessor">#define USB_OTGSC_VD_MASK (0x1U)</span></div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a263d93dc4f724ab6fd33338de1acae30"> 1638</a></span><span class="preprocessor">#define USB_OTGSC_VD_SHIFT (0U)</span></div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac199eed467553086791c2c365606ba80"> 1639</a></span><span class="preprocessor">#define USB_OTGSC_VD_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTGSC_VD_SHIFT) &amp; USB_OTGSC_VD_MASK)</span></div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a40d692e44c4907712c8c97649a9d8250"> 1640</a></span><span class="preprocessor">#define USB_OTGSC_VD_GET(x) (((uint32_t)(x) &amp; USB_OTGSC_VD_MASK) &gt;&gt; USB_OTGSC_VD_SHIFT)</span></div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span> </div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span><span class="comment">/* Bitfield definition for register: USBMODE */</span></div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span><span class="comment">/*</span></div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span><span class="comment"> * SDIS (RW)</span></div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span><span class="comment"> *</span></div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span><span class="comment"> * SDIS</span></div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span><span class="comment"> * Stream Disable Mode. (0 - Inactive [default]; 1 - Active)</span></div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span><span class="comment"> * Device Mode: Setting to a &#39;1&#39; disables double priming on both RX and TX for low bandwidth systems.</span></div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span><span class="comment"> * This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems.</span></div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span><span class="comment"> * Note: In High Speed Mode, all packets received are responded to with a NYET handshake when stream disable is active.</span></div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span><span class="comment"> * Host Mode: Setting to a &#39;1&#39; ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems</span></div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span><span class="comment"> * where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the TX latency is filled to capacity before the packet is launched onto the USB.</span></div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span><span class="comment"> * NOTE: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING and TXTTFILLTUNING [MPH Only] to characterize the adjustments needed for</span></div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span><span class="comment"> * the scheduler when using this feature.</span></div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span><span class="comment"> * NOTE: The use of this feature substantially limits of the overall USB performance that can be achieved.</span></div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span><span class="comment"> */</span></div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a893b49f3325d47e8ff193df4a49607d0"> 1657</a></span><span class="preprocessor">#define USB_USBMODE_SDIS_MASK (0x10U)</span></div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac483ad31b704eb235fe0e165b2663868"> 1658</a></span><span class="preprocessor">#define USB_USBMODE_SDIS_SHIFT (4U)</span></div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a61387bced1672ef40567f82563648c99"> 1659</a></span><span class="preprocessor">#define USB_USBMODE_SDIS_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBMODE_SDIS_SHIFT) &amp; USB_USBMODE_SDIS_MASK)</span></div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aef87ed8a3777df3148b765fb7ac033ab"> 1660</a></span><span class="preprocessor">#define USB_USBMODE_SDIS_GET(x) (((uint32_t)(x) &amp; USB_USBMODE_SDIS_MASK) &gt;&gt; USB_USBMODE_SDIS_SHIFT)</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"> 1661</span> </div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span><span class="comment">/*</span></div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span><span class="comment"> * SLOM (RW)</span></div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span><span class="comment"> *</span></div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span><span class="comment"> * SLOM</span></div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span><span class="comment"> * Setup Lockout Mode. In device mode, this bit controls behavior of the setup lock mechanism. See Control Endpoint Operation Model .</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span><span class="comment"> * 0 - Setup Lockouts On (default);</span></div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span><span class="comment"> * 1 - Setup Lockouts Off. DCD requires use of Setup Data Buffer Tripwire in USBCMD.</span></div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"> 1669</span><span class="comment"> */</span></div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3003e3150c402de936e39c8ba206687d"> 1670</a></span><span class="preprocessor">#define USB_USBMODE_SLOM_MASK (0x8U)</span></div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a15774a69a82480305563655946efb47a"> 1671</a></span><span class="preprocessor">#define USB_USBMODE_SLOM_SHIFT (3U)</span></div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad18af341a28edeb0d9e0bd551b414589"> 1672</a></span><span class="preprocessor">#define USB_USBMODE_SLOM_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBMODE_SLOM_SHIFT) &amp; USB_USBMODE_SLOM_MASK)</span></div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9095addee3286d6405419efd92ba406a"> 1673</a></span><span class="preprocessor">#define USB_USBMODE_SLOM_GET(x) (((uint32_t)(x) &amp; USB_USBMODE_SLOM_MASK) &gt;&gt; USB_USBMODE_SLOM_SHIFT)</span></div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span> </div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span><span class="comment">/*</span></div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span><span class="comment"> * ES (RW)</span></div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span><span class="comment"> *</span></div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span><span class="comment"> * ES</span></div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span><span class="comment"> * Endian Select - Read/Write. This bit can change the byte alignment of the transfer buffers to match the</span></div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span><span class="comment"> * host microprocessor. The bit fields in the microprocessor interface and the data structures are unaffected</span></div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span><span class="comment"> * by the value of this bit because they are based upon the 32-bit word.</span></div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span><span class="comment"> * Bit Meaning</span></div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span><span class="comment"> * 0 - Little Endian [Default]</span></div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span><span class="comment"> * 1 - Big Endian</span></div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span><span class="comment"> */</span></div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a15bee6f21ecf85256c1eba67b0930259"> 1686</a></span><span class="preprocessor">#define USB_USBMODE_ES_MASK (0x4U)</span></div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6c68223314b0242a0a7c2e80b61eb815"> 1687</a></span><span class="preprocessor">#define USB_USBMODE_ES_SHIFT (2U)</span></div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1a7025272597e812d5c247445c42a121"> 1688</a></span><span class="preprocessor">#define USB_USBMODE_ES_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBMODE_ES_SHIFT) &amp; USB_USBMODE_ES_MASK)</span></div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aed67f1f8bd350865a7daf7ecc281f175"> 1689</a></span><span class="preprocessor">#define USB_USBMODE_ES_GET(x) (((uint32_t)(x) &amp; USB_USBMODE_ES_MASK) &gt;&gt; USB_USBMODE_ES_SHIFT)</span></div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span> </div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span><span class="comment">/*</span></div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span><span class="comment"> * CM (RW)</span></div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span><span class="comment"> *</span></div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span><span class="comment"> * CM</span></div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span><span class="comment"> * Controller Mode - R/WO. Controller mode is defaulted to the proper mode for host only and device only</span></div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span><span class="comment"> * implementations. For those designs that contain both host &amp; device capability, the controller defaults to</span></div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span><span class="comment"> * an idle state and needs to be initialized to the desired operating mode after reset. For combination host/</span></div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span><span class="comment"> * device controllers, this register can only be written once after reset. If it is necessary to switch modes,</span></div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span><span class="comment"> * software must reset the controller by writing to the RESET bit in the USBCMD register before</span></div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span><span class="comment"> * reprogramming this register.</span></div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span><span class="comment"> * For OTG controller core, reset value is &#39;00b&#39;.</span></div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span><span class="comment"> * 00 - Idle [Default for combination host/device]</span></div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span><span class="comment"> * 01 - Reserved</span></div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span><span class="comment"> * 10 - Device Controller [Default for device only controller]</span></div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span><span class="comment"> * 11 - Host Controller [Default for host only controller]</span></div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span><span class="comment"> */</span></div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a79aafc6ef83fead6a9c6e7ce662bbc19"> 1707</a></span><span class="preprocessor">#define USB_USBMODE_CM_MASK (0x3U)</span></div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abbce73baba01f741e49faa58b74d569e"> 1708</a></span><span class="preprocessor">#define USB_USBMODE_CM_SHIFT (0U)</span></div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aca4bb14900c81bce7fbd340c7a474be4"> 1709</a></span><span class="preprocessor">#define USB_USBMODE_CM_SET(x) (((uint32_t)(x) &lt;&lt; USB_USBMODE_CM_SHIFT) &amp; USB_USBMODE_CM_MASK)</span></div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6892c9ff254b129dd371c91994db5cf8"> 1710</a></span><span class="preprocessor">#define USB_USBMODE_CM_GET(x) (((uint32_t)(x) &amp; USB_USBMODE_CM_MASK) &gt;&gt; USB_USBMODE_CM_SHIFT)</span></div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span> </div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span><span class="comment">/* Bitfield definition for register: ENDPTSETUPSTAT */</span></div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span><span class="comment">/*</span></div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span><span class="comment"> * ENDPTSETUPSTAT (RWC)</span></div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"> 1715</span><span class="comment"> *</span></div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span><span class="comment"> * ENDPTSETUPSTAT</span></div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span><span class="comment"> * Setup Endpoint Status. For every setup transaction that is received, a corresponding bit in this register is set to one.</span></div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span><span class="comment"> * Software must clear or acknowledge the setup transfer by writing a one to a respective bit after it has read the setup data from Queue head.</span></div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span><span class="comment"> * The response to a setup packet as in the order of operations and total response time is crucial to limit bus time outs while the setup lock out mechanism is engaged.</span></div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span><span class="comment"> * This register is only used in device mode.</span></div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span><span class="comment"> */</span></div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9eea7eb150151cf56232193915a3d99e"> 1722</a></span><span class="preprocessor">#define USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a14288581aa8e8b823cda272fad9416cb"> 1723</a></span><span class="preprocessor">#define USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_SHIFT (0U)</span></div>
<div class="line"><a id="l01724" name="l01724"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab4095569b24f0355c58927a67ad1f0ad"> 1724</a></span><span class="preprocessor">#define USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_SHIFT) &amp; USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_MASK)</span></div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af668007cc4357e2c1cbb8411a2062c22"> 1725</a></span><span class="preprocessor">#define USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_GET(x) (((uint32_t)(x) &amp; USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_MASK) &gt;&gt; USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_SHIFT)</span></div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span> </div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span><span class="comment">/* Bitfield definition for register: ENDPTPRIME */</span></div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span><span class="comment">/*</span></div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span><span class="comment"> * PETB (RWS)</span></div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span><span class="comment"> *</span></div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span><span class="comment"> * PETB</span></div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span><span class="comment"> * Prime Endpoint Transmit Buffer - R/WS. For each endpoint a corresponding bit is used to request that a</span></div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span><span class="comment"> * buffer is prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction.</span></div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span><span class="comment"> * Software should write a one to the corresponding bit when posting a new transfer descriptor to an</span></div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span><span class="comment"> * endpoint queue head. Hardware automatically uses this bit to begin parsing for a new transfer descriptor</span></div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span><span class="comment"> * from the queue head and prepare a transmit buffer. Hardware clears this bit when the associated</span></div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span><span class="comment"> * endpoint(s) is (are) successfully primed.</span></div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span><span class="comment"> * NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD</span></div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span><span class="comment"> * is retired, and the dQH is updated.</span></div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span><span class="comment"> * PETB[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span><span class="comment"> */</span></div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5e39d4cc521f6a189a59a2b05093c8aa"> 1742</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PETB_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adfb957209e00f9b24ce767a55c59ac79"> 1743</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PETB_SHIFT (16U)</span></div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a64043cca74460ac979eab3cbcc638f9d"> 1744</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PETB_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTPRIME_PETB_SHIFT) &amp; USB_ENDPTPRIME_PETB_MASK)</span></div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1a4e9223f5b2adf089104cee1e8a37a4"> 1745</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PETB_GET(x) (((uint32_t)(x) &amp; USB_ENDPTPRIME_PETB_MASK) &gt;&gt; USB_ENDPTPRIME_PETB_SHIFT)</span></div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"> 1746</span> </div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span><span class="comment">/*</span></div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span><span class="comment"> * PERB (RWS)</span></div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span><span class="comment"> *</span></div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span><span class="comment"> * PERB</span></div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span><span class="comment"> * Prime Endpoint Receive Buffer - R/WS. For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction.</span></div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span><span class="comment"> * Software should write a one to the corresponding bit whenever posting a new transfer descriptor to an endpoint queue head.</span></div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span><span class="comment"> * Hardware automatically uses this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer.</span></div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span><span class="comment"> * Hardware clears this bit when the associated endpoint(s) is (are) successfully primed.</span></div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span><span class="comment"> * NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD</span></div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span><span class="comment"> * is retired, and the dQH is updated.</span></div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span><span class="comment"> * PERB[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span><span class="comment"> */</span></div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5184cb0f426b12829a0ebce3f036556b"> 1759</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PERB_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4dfb30e41d44595c48fd4474554de7ac"> 1760</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PERB_SHIFT (0U)</span></div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae3265c4c5ef6eeff5d5ffc9531edf815"> 1761</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PERB_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTPRIME_PERB_SHIFT) &amp; USB_ENDPTPRIME_PERB_MASK)</span></div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afa4690e5268313aa242c7856419bbef1"> 1762</a></span><span class="preprocessor">#define USB_ENDPTPRIME_PERB_GET(x) (((uint32_t)(x) &amp; USB_ENDPTPRIME_PERB_MASK) &gt;&gt; USB_ENDPTPRIME_PERB_SHIFT)</span></div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span> </div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span><span class="comment">/* Bitfield definition for register: ENDPTFLUSH */</span></div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span><span class="comment">/*</span></div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span><span class="comment"> * FETB (RWS)</span></div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span><span class="comment"> *</span></div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span><span class="comment"> * FETB</span></div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span><span class="comment"> * Flush Endpoint Transmit Buffer - R/WS. Writing one to a bit(s) in this register causes the associated endpoint(s) to clear any primed buffers.</span></div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span><span class="comment"> * If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.</span></div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span><span class="comment"> * Hardware clears this register after the endpoint flush operation is successful.</span></div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span><span class="comment"> * FETB[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"> 1773</span><span class="comment"> */</span></div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4835e24204adc02f25bd75220f017a1e"> 1774</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FETB_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abdcfadd36d5aa454447d89a393b79e3e"> 1775</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FETB_SHIFT (16U)</span></div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a25cff46f1625fb722d24aacbd526625f"> 1776</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FETB_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTFLUSH_FETB_SHIFT) &amp; USB_ENDPTFLUSH_FETB_MASK)</span></div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9efc5b0ff1f66ec9c27a99a6b8247124"> 1777</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FETB_GET(x) (((uint32_t)(x) &amp; USB_ENDPTFLUSH_FETB_MASK) &gt;&gt; USB_ENDPTFLUSH_FETB_SHIFT)</span></div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span> </div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span><span class="comment">/*</span></div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span><span class="comment"> * FERB (RWS)</span></div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span><span class="comment"> *</span></div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span><span class="comment"> * FERB</span></div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"> 1783</span><span class="comment"> * Flush Endpoint Receive Buffer - R/WS. Writing one to a bit(s) causes the associated endpoint(s) to clear any primed buffers.</span></div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span><span class="comment"> *  If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.</span></div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span><span class="comment"> * Hardware clears this register after the endpoint flush operation is successful.</span></div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span><span class="comment"> * FERB[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span><span class="comment"> */</span></div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad2d8c38fecb23eca626d78ab89fdf4e9"> 1788</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FERB_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1844f63141977c331baec5fc0b31fbd2"> 1789</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FERB_SHIFT (0U)</span></div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a91d07db1b1a2b19da380771b4f983ac2"> 1790</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FERB_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTFLUSH_FERB_SHIFT) &amp; USB_ENDPTFLUSH_FERB_MASK)</span></div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6bbbfdd3deddb062e672599692703639"> 1791</a></span><span class="preprocessor">#define USB_ENDPTFLUSH_FERB_GET(x) (((uint32_t)(x) &amp; USB_ENDPTFLUSH_FERB_MASK) &gt;&gt; USB_ENDPTFLUSH_FERB_SHIFT)</span></div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span> </div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span><span class="comment">/* Bitfield definition for register: ENDPTSTAT */</span></div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span><span class="comment">/*</span></div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span><span class="comment"> * ETBR (RO)</span></div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span><span class="comment"> *</span></div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span><span class="comment"> * ETBR</span></div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span><span class="comment"> * Endpoint Transmit Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective endpoint buffer.</span></div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span><span class="comment"> * This bit is set to one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register.</span></div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span><span class="comment"> * There is always a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready.</span></div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span><span class="comment"> * This delay time varies based upon the current USB traffic and the number of bits set in the ENDPRIME register.</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"> 1802</span><span class="comment"> * Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.</span></div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span><span class="comment"> * NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations when a dTD is retired, and the dQH is updated.</span></div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span><span class="comment"> * ETBR[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span><span class="comment"> */</span></div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a778c5d951c1f9953b34500eef7e4a195"> 1806</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ETBR_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a03b7d8ad862205f485bc4d50f500bd0f"> 1807</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ETBR_SHIFT (16U)</span></div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad9d642ff33845873bf980c7a62fc9e81"> 1808</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ETBR_GET(x) (((uint32_t)(x) &amp; USB_ENDPTSTAT_ETBR_MASK) &gt;&gt; USB_ENDPTSTAT_ETBR_SHIFT)</span></div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span> </div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span><span class="comment">/*</span></div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span><span class="comment"> * ERBR (RO)</span></div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span><span class="comment"> *</span></div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span><span class="comment"> * ERBR</span></div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span><span class="comment"> * Endpoint Receive Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective</span></div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span><span class="comment"> * endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a</span></div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span><span class="comment"> * corresponding bit in the ENDPRIME register. There is always a delay between setting a bit in the</span></div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span><span class="comment"> * ENDPRIME register and endpoint indicating ready. This delay time varies based upon the current USB</span></div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span><span class="comment"> * traffic and the number of bits set in the ENDPRIME register. Buffer ready is cleared by USB reset, by the</span></div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span><span class="comment"> * USB DMA system, or through the ENDPTFLUSH register.</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span><span class="comment"> * NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span><span class="comment"> * when a dTD is retired, and the dQH is updated.</span></div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span><span class="comment"> * ERBR[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span><span class="comment"> */</span></div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a311946de199127e480557c6573ab11d5"> 1824</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ERBR_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aadaaf298049601d1328022e7fbd77b0e"> 1825</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ERBR_SHIFT (0U)</span></div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abdb904d9f64b6600ffe326fbf9429f97"> 1826</a></span><span class="preprocessor">#define USB_ENDPTSTAT_ERBR_GET(x) (((uint32_t)(x) &amp; USB_ENDPTSTAT_ERBR_MASK) &gt;&gt; USB_ENDPTSTAT_ERBR_SHIFT)</span></div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span> </div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span><span class="comment">/* Bitfield definition for register: ENDPTCOMPLETE */</span></div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span><span class="comment">/*</span></div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span><span class="comment"> * ETCE (RWC)</span></div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span><span class="comment"> *</span></div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span><span class="comment"> * ETCE</span></div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span><span class="comment"> * Endpoint Transmit Complete Event - R/WC. Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status.</span></div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span><span class="comment"> * If the corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the USBINT . Writing one clears the corresponding bit in this register.</span></div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span><span class="comment"> * ETCE[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span><span class="comment"> */</span></div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af615a1603b242262b33db5c28af840af"> 1837</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ETCE_MASK (0xFFFF0000UL)</span></div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4cec73fce11350ff257ef39605d20c38"> 1838</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ETCE_SHIFT (16U)</span></div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aabfe73ae2d5921c6f4f678ec4c9bc81f"> 1839</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ETCE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCOMPLETE_ETCE_SHIFT) &amp; USB_ENDPTCOMPLETE_ETCE_MASK)</span></div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a683d1678ea4f88176710e9097f81ccd2"> 1840</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ETCE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCOMPLETE_ETCE_MASK) &gt;&gt; USB_ENDPTCOMPLETE_ETCE_SHIFT)</span></div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span> </div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span><span class="comment">/*</span></div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span><span class="comment"> * ERCE (RWC)</span></div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span><span class="comment"> *</span></div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span><span class="comment"> * ERCE</span></div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span><span class="comment"> * Endpoint Receive Complete Event - RW/C. Each bit indicates a received event (OUT/SETUP) occurred</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span><span class="comment"> * and software should read the corresponding endpoint queue to determine the transfer status. If the</span></div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"> 1848</span><span class="comment"> * corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the</span></div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span><span class="comment"> * USBINT . Writing one clears the corresponding bit in this register.</span></div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span><span class="comment"> * ERCE[N] - Endpoint #N, N is in 0..7</span></div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span><span class="comment"> */</span></div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3c6a19089f0a69ec2328df03e4591a02"> 1852</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ERCE_MASK (0xFFFFU)</span></div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aca06d9ceb1b6901a880a7dc89a0d339d"> 1853</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ERCE_SHIFT (0U)</span></div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a94c2fb7da8c9d3e25e6a4eb86ae67259"> 1854</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ERCE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCOMPLETE_ERCE_SHIFT) &amp; USB_ENDPTCOMPLETE_ERCE_MASK)</span></div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2a11e110b8c5213fc7d3a9cd5e1f0777"> 1855</a></span><span class="preprocessor">#define USB_ENDPTCOMPLETE_ERCE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCOMPLETE_ERCE_MASK) &gt;&gt; USB_ENDPTCOMPLETE_ERCE_SHIFT)</span></div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span> </div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"> 1857</span><span class="comment">/* Bitfield definition for register array: ENDPTCTRL */</span></div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span><span class="comment">/*</span></div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span><span class="comment"> * TXE (RW)</span></div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"> 1860</span><span class="comment"> *</span></div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span><span class="comment"> * TXE</span></div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span><span class="comment"> * TX Endpoint Enable</span></div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"> 1863</span><span class="comment"> * 0 Disabled [Default]</span></div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span><span class="comment"> * 1 Enabled</span></div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span><span class="comment"> * An Endpoint should be enabled only after it has been configured.</span></div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span><span class="comment"> */</span></div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a94ad98970522c322e0c07aa3468ba0ba"> 1867</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXE_MASK (0x800000UL)</span></div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aab733e966ad4c80d1169a16d11b1f60f"> 1868</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXE_SHIFT (23U)</span></div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a754a25b6cfdd841dfecdb3562caa82ed"> 1869</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_TXE_SHIFT) &amp; USB_ENDPTCTRL_TXE_MASK)</span></div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad1790aa556cdb9b40c8a10cc7a95eee4"> 1870</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_TXE_MASK) &gt;&gt; USB_ENDPTCTRL_TXE_SHIFT)</span></div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span> </div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span><span class="comment">/*</span></div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span><span class="comment"> * TXR (WS)</span></div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span><span class="comment"> *</span></div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span><span class="comment"> * TXR</span></div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"> 1876</span><span class="comment"> * TX Data Toggle Reset (WS)</span></div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span><span class="comment"> * Write 1 - Reset PID Sequence</span></div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span><span class="comment"> * Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order</span></div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span><span class="comment"> * to synchronize the data PID&#39;s between the Host and device.</span></div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span><span class="comment"> */</span></div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac3547c8433d512aaa8a09873f0052e4c"> 1881</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXR_MASK (0x400000UL)</span></div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae3e2f0a1597d096bb04863dabb061489"> 1882</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXR_SHIFT (22U)</span></div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6ddb349c5138ddf9996f7ef962536b82"> 1883</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXR_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_TXR_SHIFT) &amp; USB_ENDPTCTRL_TXR_MASK)</span></div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7c1b130b1094b2b2091f6059e0701b68"> 1884</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXR_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_TXR_MASK) &gt;&gt; USB_ENDPTCTRL_TXR_SHIFT)</span></div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span> </div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span><span class="comment">/*</span></div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span><span class="comment"> * TXT (RW)</span></div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span><span class="comment"> *</span></div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span><span class="comment"> * TXT</span></div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span><span class="comment"> * TX Endpoint Type - Read/Write</span></div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span><span class="comment"> * 00 Control</span></div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span><span class="comment"> * 01 Isochronous</span></div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"> 1893</span><span class="comment"> * 10 Bulk</span></div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span><span class="comment"> * 11 Interrupt</span></div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span><span class="comment"> */</span></div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acd3a6ef29f129ad18cdc52433ea68284"> 1896</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXT_MASK (0xC0000UL)</span></div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8c9dfcd09d23748e8011541b8016da72"> 1897</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXT_SHIFT (18U)</span></div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0c609bb95cc5261b04f9d0ffe5b8d400"> 1898</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXT_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_TXT_SHIFT) &amp; USB_ENDPTCTRL_TXT_MASK)</span></div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac283a54d5559f62cec0a0cf434ad953a"> 1899</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXT_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_TXT_MASK) &gt;&gt; USB_ENDPTCTRL_TXT_SHIFT)</span></div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span> </div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"> 1901</span><span class="comment">/*</span></div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span><span class="comment"> * TXS (RW)</span></div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span><span class="comment"> *</span></div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span><span class="comment"> * TXS</span></div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span><span class="comment"> * TX Endpoint Stall - Read/Write</span></div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span><span class="comment"> * 0 End Point OK</span></div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span><span class="comment"> * 1 End Point Stalled</span></div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"> 1908</span><span class="comment"> * This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured</span></div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span><span class="comment"> * as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.</span></div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span><span class="comment"> * Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host.</span></div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span><span class="comment"> * This control will continue to STALL until this bit is either cleared by software or automatically cleared as above for control endpoints.</span></div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span><span class="comment"> * NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit.</span></div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span><span class="comment"> * In most systems, it is unlikely the DCD software will observe this delay. However, should the DCD observe that the stall bit is not set after writing a one to it then follow this procedure:</span></div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"> 1914</span><span class="comment"> * continually write this stall bit until it is set or until a new setup has been received by checking the associated endptsetupstat Bit.</span></div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span><span class="comment"> */</span></div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab2af4bca6c32ac346556e76aa84a8966"> 1916</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXS_MASK (0x10000UL)</span></div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2937be33de98ecdbfa6593d967ce05c1"> 1917</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXS_SHIFT (16U)</span></div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0721a47f6c4c56e1729249a7fdea8049"> 1918</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXS_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_TXS_SHIFT) &amp; USB_ENDPTCTRL_TXS_MASK)</span></div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0f9929061f1582d239130ae6abcf0c5a"> 1919</a></span><span class="preprocessor">#define USB_ENDPTCTRL_TXS_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_TXS_MASK) &gt;&gt; USB_ENDPTCTRL_TXS_SHIFT)</span></div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span> </div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span><span class="comment">/*</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"> 1922</span><span class="comment"> * RXE (RW)</span></div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span><span class="comment"> *</span></div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span><span class="comment"> * RXE</span></div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"> 1925</span><span class="comment"> * RX Endpoint Enable</span></div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span><span class="comment"> * 0 Disabled [Default]</span></div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span><span class="comment"> * 1 Enabled</span></div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"> 1928</span><span class="comment"> * An Endpoint should be enabled only after it has been configured.</span></div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span><span class="comment"> */</span></div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5e20f68f482223bdcd7546cccf6895d0"> 1930</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXE_MASK (0x80U)</span></div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3a124c78cc63ffd028b2d1fee1d1b8fc"> 1931</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXE_SHIFT (7U)</span></div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac2cd7e48f00178d0f10cce0dd8f53724"> 1932</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXE_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_RXE_SHIFT) &amp; USB_ENDPTCTRL_RXE_MASK)</span></div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a86edc1bac3493ef8cc2a17dd1167d8d9"> 1933</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXE_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_RXE_MASK) &gt;&gt; USB_ENDPTCTRL_RXE_SHIFT)</span></div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span> </div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span><span class="comment">/*</span></div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span><span class="comment"> * RXR (WS)</span></div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span><span class="comment"> *</span></div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span><span class="comment"> * RXR</span></div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span><span class="comment"> * RX Data Toggle Reset (WS)</span></div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span><span class="comment"> * Write 1 - Reset PID Sequence</span></div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span><span class="comment"> * Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order</span></div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span><span class="comment"> * to synchronize the data PID&#39;s between the host and device.</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span><span class="comment"> */</span></div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2ea3697148b3f8ad4a43476c9fa8599b"> 1944</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXR_MASK (0x40U)</span></div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a11f5ba42eded34b7ad18e5633ec20655"> 1945</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXR_SHIFT (6U)</span></div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab95e578baaf21aec3e332f9394ab78d5"> 1946</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXR_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_RXR_SHIFT) &amp; USB_ENDPTCTRL_RXR_MASK)</span></div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aef8ec44e31b72f4e2e64a873ca477a9c"> 1947</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXR_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_RXR_MASK) &gt;&gt; USB_ENDPTCTRL_RXR_SHIFT)</span></div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"> 1948</span> </div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span><span class="comment">/*</span></div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span><span class="comment"> * RXT (RW)</span></div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span><span class="comment"> *</span></div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span><span class="comment"> * RXT</span></div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span><span class="comment"> * RX Endpoint Type - Read/Write</span></div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span><span class="comment"> * 00 Control</span></div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span><span class="comment"> * 01 Isochronous</span></div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span><span class="comment"> * 10 Bulk</span></div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span><span class="comment"> * 11 Interrupt</span></div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span><span class="comment"> */</span></div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac6d7085fbeae7d670ecb52837ddd478e"> 1959</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXT_MASK (0xCU)</span></div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adfde895eb09933e50dc9d0e84ee61bfb"> 1960</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXT_SHIFT (2U)</span></div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af0a4fba012c4b06c0eb2a88634abf024"> 1961</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXT_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_RXT_SHIFT) &amp; USB_ENDPTCTRL_RXT_MASK)</span></div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af4d4fc573520a08afe07199c73131b08"> 1962</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXT_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_RXT_MASK) &gt;&gt; USB_ENDPTCTRL_RXT_SHIFT)</span></div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span> </div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span><span class="comment">/*</span></div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span><span class="comment"> * RXS (RW)</span></div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span><span class="comment"> *</span></div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span><span class="comment"> * RXS</span></div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span><span class="comment"> * RX Endpoint Stall - Read/Write</span></div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span><span class="comment"> * 0 End Point OK. [Default]</span></div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span><span class="comment"> * 1 End Point Stalled</span></div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span><span class="comment"> * This bit is set automatically upon receipt of a SETUP request if this Endpoint is configured as a Control</span></div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span><span class="comment"> * Endpointand this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit</span></div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"> 1973</span><span class="comment"> * is cleared.</span></div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span><span class="comment"> * Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. This</span></div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span><span class="comment"> * control will continue to STALL until this bit is either cleared by software or automatically cleared as above</span></div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span><span class="comment"> * for control endpoints.</span></div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span><span class="comment"> * NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the</span></div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span><span class="comment"> * ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit. In most systems, it</span></div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span><span class="comment"> * is unlikely the DCD software will observe this delay. However, should the DCD observe that the</span></div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"> 1980</span><span class="comment"> * stall bit is not set after writing a one to it then follow this procedure: continually write this stall bit</span></div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span><span class="comment"> * until it is set or until a new setup has been received by checking the associated endptsetupstat</span></div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span><span class="comment"> * Bit.</span></div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span><span class="comment"> */</span></div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac71f27a499ef17c98b26c7bf272522c0"> 1984</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXS_MASK (0x1U)</span></div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1e3ca7c7ee444e7877dde754eeeaa114"> 1985</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXS_SHIFT (0U)</span></div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a402e68b1ea874be84fccb89b3e42da21"> 1986</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXS_SET(x) (((uint32_t)(x) &lt;&lt; USB_ENDPTCTRL_RXS_SHIFT) &amp; USB_ENDPTCTRL_RXS_MASK)</span></div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad97224755b6b0aa38fdb6fd9a126f3ae"> 1987</a></span><span class="preprocessor">#define USB_ENDPTCTRL_RXS_GET(x) (((uint32_t)(x) &amp; USB_ENDPTCTRL_RXS_MASK) &gt;&gt; USB_ENDPTCTRL_RXS_SHIFT)</span></div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span> </div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span><span class="comment">/* Bitfield definition for register: OTG_CTRL0 */</span></div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span><span class="comment">/*</span></div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span><span class="comment"> * OTG_WKDPDMCHG_EN (RW)</span></div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span><span class="comment"> *</span></div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"> 1993</span><span class="comment"> */</span></div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2130b8aa5bd65b60d7da0d57c78e6ede"> 1994</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_MASK (0x2000000UL)</span></div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6a9430442fd4135ffdda60a598a4a9fa"> 1995</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_SHIFT (25U)</span></div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a26c66eb8f0d3addd423f522fe3ff16c8"> 1996</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_SHIFT) &amp; USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_MASK)</span></div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab0e1aef14d73f7087fde31aebe6e73a5"> 1997</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_WKDPDMCHG_EN_SHIFT)</span></div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"> 1998</span> </div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span><span class="comment">/*</span></div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span><span class="comment"> * AUTORESUME_EN (RW)</span></div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"> 2001</span><span class="comment"> *</span></div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span><span class="comment"> */</span></div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a71e9a2ae139f04c4537b8cfb87784094"> 2003</a></span><span class="preprocessor">#define USB_OTG_CTRL0_AUTORESUME_EN_MASK (0x80000UL)</span></div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad67df9607d3686a1c398ac3a8acbf9f5"> 2004</a></span><span class="preprocessor">#define USB_OTG_CTRL0_AUTORESUME_EN_SHIFT (19U)</span></div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7ffef5d19a5320bd79f6118599f19eb6"> 2005</a></span><span class="preprocessor">#define USB_OTG_CTRL0_AUTORESUME_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_AUTORESUME_EN_SHIFT) &amp; USB_OTG_CTRL0_AUTORESUME_EN_MASK)</span></div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae3b654b1039e386676f74866c60ca1d6"> 2006</a></span><span class="preprocessor">#define USB_OTG_CTRL0_AUTORESUME_EN_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_AUTORESUME_EN_MASK) &gt;&gt; USB_OTG_CTRL0_AUTORESUME_EN_SHIFT)</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"> 2007</span> </div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span><span class="comment">/*</span></div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span><span class="comment"> * OTG_VBUS_WAKEUP_EN (RW)</span></div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span><span class="comment"> *</span></div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span><span class="comment"> */</span></div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af56ba737ae3787e56544ad3aeb3c957d"> 2012</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_MASK (0x20000UL)</span></div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a18a909d90502ad5d8b4145ffce86fa3b"> 2013</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_SHIFT (17U)</span></div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa5b307b457132477a64c9edf8dbc335a"> 2014</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_SHIFT) &amp; USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_MASK)</span></div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad75e5ea92dc2ec00cbaab7eb090cde5a"> 2015</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_VBUS_WAKEUP_EN_SHIFT)</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span> </div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"> 2017</span><span class="comment">/*</span></div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span><span class="comment"> * OTG_ID_WAKEUP_EN (RW)</span></div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span><span class="comment"> *</span></div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span><span class="comment"> */</span></div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab04757155bf6c39c2fe3c6a9d313a3be"> 2021</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_MASK (0x10000UL)</span></div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a58a9c9e274220fc4403ea70ada4ace70"> 2022</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_SHIFT (16U)</span></div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3d3028d45270c2a27673618ec120c980"> 2023</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_SHIFT) &amp; USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_MASK)</span></div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abbbec4e1ee3b8c7fadd48e73b2c39549"> 2024</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_ID_WAKEUP_EN_SHIFT)</span></div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span> </div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span><span class="comment">/*</span></div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span><span class="comment"> * OTG_VBUS_SOURCE_SEL (RW)</span></div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span><span class="comment"> *</span></div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span><span class="comment"> */</span></div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a451a3760558d82b0ffcce89536ce9dea"> 2030</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_MASK (0x2000U)</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a61b4874d1ba6141dff04ffb82de3207f"> 2031</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_SHIFT (13U)</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a33118930b3e885420ea366bddabb1cff"> 2032</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_SHIFT) &amp; USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_MASK)</span></div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#addcc105b8eb6e5ac9d0b650b2124c314"> 2033</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_VBUS_SOURCE_SEL_SHIFT)</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span> </div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span><span class="comment">/*</span></div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"> 2036</span><span class="comment"> * OTG_UTMI_SUSPENDM_SW (RW)</span></div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span><span class="comment"> *</span></div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span><span class="comment"> * default 0 for naneng usbphy</span></div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span><span class="comment"> */</span></div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2302df28682491958bd12b3a2b698f31"> 2040</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_MASK (0x1000U)</span></div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1ef0a298d5ef6ddc0e4dea9ffdf2a50f"> 2041</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_SHIFT (12U)</span></div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7ef6c23ede4584028eccd29a31d03cba"> 2042</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_SHIFT) &amp; USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_MASK)</span></div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa1f173b2d9ac9e72cef5d23ef4fa0112"> 2043</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_UTMI_SUSPENDM_SW_SHIFT)</span></div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span> </div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span><span class="comment">/*</span></div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span><span class="comment"> * OTG_UTMI_RESET_SW (RW)</span></div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"> 2047</span><span class="comment"> *</span></div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span><span class="comment"> * default 1 for naneng usbphy</span></div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span><span class="comment"> */</span></div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a333f700eab98e3f6dc8c8fd2c29970b4"> 2050</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_RESET_SW_MASK (0x800U)</span></div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2afdc522e416a70099f1205ad2d45324"> 2051</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_RESET_SW_SHIFT (11U)</span></div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afcc939bd0d22338a41c224bfd12e884f"> 2052</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_RESET_SW_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_UTMI_RESET_SW_SHIFT) &amp; USB_OTG_CTRL0_OTG_UTMI_RESET_SW_MASK)</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3a238d9c246ab6965812b50c13a03a0d"> 2053</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_UTMI_RESET_SW_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_UTMI_RESET_SW_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_UTMI_RESET_SW_SHIFT)</span></div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span> </div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span><span class="comment">/*</span></div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span><span class="comment"> * OTG_WAKEUP_INT_ENABLE (RW)</span></div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span><span class="comment"> *</span></div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span><span class="comment"> */</span></div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a30ff12fd0b56cbf80825f65b920e771a"> 2059</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_MASK (0x400U)</span></div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aeadd5fc39919e11ea2b93a48211b771c"> 2060</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_SHIFT (10U)</span></div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0480d5c9c2e9a288efc5cf4c620a415b"> 2061</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_SHIFT) &amp; USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_MASK)</span></div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3b262bd7b2271b923f2b4fae3a7179fe"> 2062</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_WAKEUP_INT_ENABLE_SHIFT)</span></div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span> </div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span><span class="comment">/*</span></div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span><span class="comment"> * OTG_POWER_MASK (RW)</span></div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span><span class="comment"> *</span></div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span><span class="comment"> */</span></div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7272311a427a7ed9122b772c64f47e62"> 2068</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_POWER_MASK_MASK (0x200U)</span></div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad736673f45ead031bf61d2199f7e53a8"> 2069</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_POWER_MASK_SHIFT (9U)</span></div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af52749dedd78ea3937baa9cbd5ba1a23"> 2070</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_POWER_MASK_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_POWER_MASK_SHIFT) &amp; USB_OTG_CTRL0_OTG_POWER_MASK_MASK)</span></div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0673ff92d40c3fb6c89489e9911b6124"> 2071</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_POWER_MASK_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_POWER_MASK_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_POWER_MASK_SHIFT)</span></div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span> </div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span><span class="comment">/*</span></div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span><span class="comment"> * OTG_OVER_CUR_POL (RW)</span></div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"> 2075</span><span class="comment"> *</span></div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span><span class="comment"> */</span></div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adf97cb4b157969b00d9e359848a71239"> 2077</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_POL_MASK (0x100U)</span></div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a75df5b020323c041964723e4d71a944c"> 2078</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_POL_SHIFT (8U)</span></div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7e5bd00cf942cb618fc69a8b2fa0d327"> 2079</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_POL_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_OVER_CUR_POL_SHIFT) &amp; USB_OTG_CTRL0_OTG_OVER_CUR_POL_MASK)</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abf6b6cb8162178fac6e4baa7e3714e2f"> 2080</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_POL_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_OVER_CUR_POL_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_OVER_CUR_POL_SHIFT)</span></div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span> </div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span><span class="comment">/*</span></div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span><span class="comment"> * OTG_OVER_CUR_DIS (RW)</span></div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span><span class="comment"> *</span></div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span><span class="comment"> */</span></div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a9f24f1b6a1bc44ab7f5c9deafac7188a"> 2086</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_DIS_MASK (0x80U)</span></div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a569d9d6ba26e4aeb4b02c0648352e20d"> 2087</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_DIS_SHIFT (7U)</span></div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4620aa773ff2491f6021b314d14c0bcd"> 2088</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_DIS_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_OTG_OVER_CUR_DIS_SHIFT) &amp; USB_OTG_CTRL0_OTG_OVER_CUR_DIS_MASK)</span></div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aca024b256ed07d3c16df9d568ef8822e"> 2089</a></span><span class="preprocessor">#define USB_OTG_CTRL0_OTG_OVER_CUR_DIS_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_OTG_OVER_CUR_DIS_MASK) &gt;&gt; USB_OTG_CTRL0_OTG_OVER_CUR_DIS_SHIFT)</span></div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span> </div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span><span class="comment">/*</span></div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span><span class="comment"> * SER_MODE_SUSPEND_EN (RW)</span></div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span><span class="comment"> *</span></div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"> 2094</span><span class="comment"> * for naneng usbphy, only switch to serial mode when suspend</span></div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span><span class="comment"> */</span></div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad44de277c83d68b6086fbd5ac86764f1"> 2096</a></span><span class="preprocessor">#define USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_MASK (0x10U)</span></div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a76c907b2247a92f8f9663c016161e154"> 2097</a></span><span class="preprocessor">#define USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_SHIFT (4U)</span></div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afcd739f02f97be91fbf22ca09d68af50"> 2098</a></span><span class="preprocessor">#define USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_SHIFT) &amp; USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_MASK)</span></div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aba12c35c462e258c218a932c3ecdde9d"> 2099</a></span><span class="preprocessor">#define USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_GET(x) (((uint32_t)(x) &amp; USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_MASK) &gt;&gt; USB_OTG_CTRL0_SER_MODE_SUSPEND_EN_SHIFT)</span></div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span> </div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span><span class="comment">/* Bitfield definition for register: PHY_CTRL0 */</span></div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"> 2102</span><span class="comment">/*</span></div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span><span class="comment"> * GPIO_ID_SEL_N (RW)</span></div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span><span class="comment"> *</span></div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span><span class="comment"> */</span></div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a19d1a220fe593b8db53907608e2835b3"> 2106</a></span><span class="preprocessor">#define USB_PHY_CTRL0_GPIO_ID_SEL_N_MASK (0x2000000UL)</span></div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af0ae304046643216fe8e06e73119408e"> 2107</a></span><span class="preprocessor">#define USB_PHY_CTRL0_GPIO_ID_SEL_N_SHIFT (25U)</span></div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#accf1854b6eff776e6ff0a9a1dd017f1d"> 2108</a></span><span class="preprocessor">#define USB_PHY_CTRL0_GPIO_ID_SEL_N_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_GPIO_ID_SEL_N_SHIFT) &amp; USB_PHY_CTRL0_GPIO_ID_SEL_N_MASK)</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adec3e7909ed8a37fcb6eb1871d1a8a2e"> 2109</a></span><span class="preprocessor">#define USB_PHY_CTRL0_GPIO_ID_SEL_N_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_GPIO_ID_SEL_N_MASK) &gt;&gt; USB_PHY_CTRL0_GPIO_ID_SEL_N_SHIFT)</span></div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span> </div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span><span class="comment">/*</span></div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span><span class="comment"> * ID_DIG_OVERRIDE (RW)</span></div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span><span class="comment"> *</span></div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span><span class="comment"> */</span></div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a24a2e0bb0e5e2ee66d58a585002845d4"> 2115</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_MASK (0x4000U)</span></div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6a436ea02d5709546faef4ec1333bfc9"> 2116</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_SHIFT (14U)</span></div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa81fb8ee14058c8bb49c9d2c01b88b8b"> 2117</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_ID_DIG_OVERRIDE_SHIFT) &amp; USB_PHY_CTRL0_ID_DIG_OVERRIDE_MASK)</span></div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1703e127342a4a0c285e562a3a1428a9"> 2118</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_ID_DIG_OVERRIDE_MASK) &gt;&gt; USB_PHY_CTRL0_ID_DIG_OVERRIDE_SHIFT)</span></div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span> </div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span><span class="comment">/*</span></div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span><span class="comment"> * SESS_VALID_OVERRIDE (RW)</span></div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span><span class="comment"> *</span></div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span><span class="comment"> */</span></div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a71130d96f7dae37bc79a5f8690861328"> 2124</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_MASK (0x2000U)</span></div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a627ed939c95e6cc55547330f0339afd9"> 2125</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_SHIFT (13U)</span></div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac046ba3a0bddba464449dfa30e32ff77"> 2126</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_SHIFT) &amp; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_MASK)</span></div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab44bfa6484ec4b43581289afd4971ea5"> 2127</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_MASK) &gt;&gt; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_SHIFT)</span></div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span> </div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span><span class="comment">/*</span></div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span><span class="comment"> * VBUS_VALID_OVERRIDE (RW)</span></div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span><span class="comment"> *</span></div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span><span class="comment"> */</span></div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a32110bef4347cc2c2600f95832c80075"> 2133</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_MASK (0x1000U)</span></div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8f4f242792da83d3076dc1767440f9ff"> 2134</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_SHIFT (12U)</span></div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5d0deb8131ed1cb5a2a5f619da7e1e7c"> 2135</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_SHIFT) &amp; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_MASK)</span></div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a131c7bab6715e9fe05969265de1e6657"> 2136</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_MASK) &gt;&gt; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_SHIFT)</span></div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span> </div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span><span class="comment">/*</span></div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span><span class="comment"> * OP_MODE_SUSPENDM_ENJ (RW)</span></div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span><span class="comment"> *</span></div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span><span class="comment"> * set op_mode to 2&#39;b01 in suspend, for naneng usbphy</span></div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span><span class="comment"> */</span></div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6e663eb83fa9f561b0070396fcad3f29"> 2143</a></span><span class="preprocessor">#define USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_MASK (0x800U)</span></div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae59a48a33a7ce0b7c6a3c3e81819a4dc"> 2144</a></span><span class="preprocessor">#define USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_SHIFT (11U)</span></div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac1bcc3e96226f3c624d0e7c26ae8dba4"> 2145</a></span><span class="preprocessor">#define USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_SHIFT) &amp; USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_MASK)</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae6095fee0a02a8809906b97c16c325f4"> 2146</a></span><span class="preprocessor">#define USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_MASK) &gt;&gt; USB_PHY_CTRL0_OP_MODE_SUSPENDM_ENJ_SHIFT)</span></div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span> </div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"> 2148</span><span class="comment">/*</span></div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span><span class="comment"> * ID_DIG_OVERRIDE_EN (RW)</span></div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span><span class="comment"> *</span></div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span><span class="comment"> */</span></div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6704290c31ee1bcab1ee667dc8aa53f3"> 2152</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_MASK (0x4U)</span></div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a25b19f6eeb5e43f3feca65e63804f49c"> 2153</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_SHIFT (2U)</span></div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a026e59e69363f7dd5668145e9146a72d"> 2154</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_SHIFT) &amp; USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_MASK)</span></div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a28536ac3b2bfb903967fb2840a3f64a6"> 2155</a></span><span class="preprocessor">#define USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_MASK) &gt;&gt; USB_PHY_CTRL0_ID_DIG_OVERRIDE_EN_SHIFT)</span></div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span> </div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span><span class="comment">/*</span></div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span><span class="comment"> * SESS_VALID_OVERRIDE_EN (RW)</span></div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span><span class="comment"> *</span></div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"> 2160</span><span class="comment"> */</span></div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af84380ddbeff3762e75948566cd49eaa"> 2161</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_MASK (0x2U)</span></div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3b574dc72d4954445037579c2c51417c"> 2162</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_SHIFT (1U)</span></div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a17eae34ce098905d81373e71522a8b36"> 2163</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_SHIFT) &amp; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_MASK)</span></div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abaded4156b4c1d5ede8fb75d6a95ba14"> 2164</a></span><span class="preprocessor">#define USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_MASK) &gt;&gt; USB_PHY_CTRL0_SESS_VALID_OVERRIDE_EN_SHIFT)</span></div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span> </div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"> 2166</span><span class="comment">/*</span></div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span><span class="comment"> * VBUS_VALID_OVERRIDE_EN (RW)</span></div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span><span class="comment"> *</span></div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span><span class="comment"> */</span></div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a4773d99ffedc7b4dc8396d8f75f5eaea"> 2170</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_MASK (0x1U)</span></div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2cddda08dbe019aa1a9258caf0b835aa"> 2171</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_SHIFT (0U)</span></div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae002fa88cac0b8a2a88133d0478c94b4"> 2172</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_SHIFT) &amp; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_MASK)</span></div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a05fc1de6ae31040d71e4b4183864274f"> 2173</a></span><span class="preprocessor">#define USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_MASK) &gt;&gt; USB_PHY_CTRL0_VBUS_VALID_OVERRIDE_EN_SHIFT)</span></div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span> </div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span><span class="comment">/* Bitfield definition for register: PHY_CTRL1 */</span></div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span><span class="comment">/*</span></div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span><span class="comment"> * UTMI_CFG_RST_N (RW)</span></div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span><span class="comment"> *</span></div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span><span class="comment"> */</span></div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a889d53455c5b7419b011df9ada42151e"> 2180</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_CFG_RST_N_MASK (0x100000UL)</span></div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6d796089560eafc8332b6436cd9027a1"> 2181</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_CFG_RST_N_SHIFT (20U)</span></div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7cd6b1a828c3fa801c01db589f380de6"> 2182</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_CFG_RST_N_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL1_UTMI_CFG_RST_N_SHIFT) &amp; USB_PHY_CTRL1_UTMI_CFG_RST_N_MASK)</span></div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ad7991a35ecc242d103c9de591b4888cf"> 2183</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_CFG_RST_N_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL1_UTMI_CFG_RST_N_MASK) &gt;&gt; USB_PHY_CTRL1_UTMI_CFG_RST_N_SHIFT)</span></div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span> </div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span><span class="comment">/*</span></div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"> 2186</span><span class="comment"> * UTMI_OTG_SUSPENDM (RW)</span></div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span><span class="comment"> *</span></div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span><span class="comment"> * OTG suspend, not utmi_suspendm.</span></div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span><span class="comment"> * setting this bit also enable host high-speed disconnect detection logic(check DP/DM voltage at end of SOF, to determine whether 50Ohm are still there on DP/DM)</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span><span class="comment"> * should clear this bit before entering into suspend state(setting portsc.phcd), avoide unwanted glitch on vbus/sess_vld/sess_end</span></div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span><span class="comment"> */</span></div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a291f4d917b06bec4ef59ab9a98eb5f21"> 2192</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_MASK (0x2U)</span></div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab72c891eed9d55075b93b5dcada4333f"> 2193</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_SHIFT (1U)</span></div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#acd3c3f975fc7a7cdd70d7debae3a0846"> 2194</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_SHIFT) &amp; USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_MASK)</span></div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7b26deec1031d06745a4b7f240a3cf7e"> 2195</a></span><span class="preprocessor">#define USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_GET(x) (((uint32_t)(x) &amp; USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_MASK) &gt;&gt; USB_PHY_CTRL1_UTMI_OTG_SUSPENDM_SHIFT)</span></div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span> </div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span><span class="comment">/* Bitfield definition for register: TOP_STATUS */</span></div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"> 2198</span><span class="comment">/*</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span><span class="comment"> * WAKEUP_INT_STATUS (RW)</span></div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span><span class="comment"> *</span></div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span><span class="comment"> */</span></div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5e3eb60b868f5b30582260ae7607bacc"> 2202</a></span><span class="preprocessor">#define USB_TOP_STATUS_WAKEUP_INT_STATUS_MASK (0x80000000UL)</span></div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aea8102e115b86199643eca30d3d1132c"> 2203</a></span><span class="preprocessor">#define USB_TOP_STATUS_WAKEUP_INT_STATUS_SHIFT (31U)</span></div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a73dc7568a7ba9dc8c7f7991b84ed37ae"> 2204</a></span><span class="preprocessor">#define USB_TOP_STATUS_WAKEUP_INT_STATUS_SET(x) (((uint32_t)(x) &lt;&lt; USB_TOP_STATUS_WAKEUP_INT_STATUS_SHIFT) &amp; USB_TOP_STATUS_WAKEUP_INT_STATUS_MASK)</span></div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afdb9824967cab5913ab4d0a7704b5675"> 2205</a></span><span class="preprocessor">#define USB_TOP_STATUS_WAKEUP_INT_STATUS_GET(x) (((uint32_t)(x) &amp; USB_TOP_STATUS_WAKEUP_INT_STATUS_MASK) &gt;&gt; USB_TOP_STATUS_WAKEUP_INT_STATUS_SHIFT)</span></div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span> </div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span><span class="comment">/* Bitfield definition for register: PHY_STATUS */</span></div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span><span class="comment">/*</span></div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span><span class="comment"> * UTMI_CLK_VALID (RW)</span></div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span><span class="comment"> *</span></div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span><span class="comment"> */</span></div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a250328db328de0bcee9bc7da9918b27a"> 2212</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_CLK_VALID_MASK (0x80000000UL)</span></div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#adf8cd85d64c0b515bcc816878f2d2458"> 2213</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_CLK_VALID_SHIFT (31U)</span></div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8e94096d32658e8a29f2c51de420a18f"> 2214</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_CLK_VALID_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_UTMI_CLK_VALID_SHIFT) &amp; USB_PHY_STATUS_UTMI_CLK_VALID_MASK)</span></div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac4b3d94d24f7e2d124f7824ca2f334f9"> 2215</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_CLK_VALID_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_UTMI_CLK_VALID_MASK) &gt;&gt; USB_PHY_STATUS_UTMI_CLK_VALID_SHIFT)</span></div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span> </div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span><span class="comment">/*</span></div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span><span class="comment"> * LINE_STATE (RW)</span></div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span><span class="comment"> *</span></div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span><span class="comment"> */</span></div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a06748851a21f41f479375b44267f0fbf"> 2221</a></span><span class="preprocessor">#define USB_PHY_STATUS_LINE_STATE_MASK (0xC0U)</span></div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#aa039ae6418e7343f6bf94d8723588d1c"> 2222</a></span><span class="preprocessor">#define USB_PHY_STATUS_LINE_STATE_SHIFT (6U)</span></div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ae531262f9effce1f41ffcca9bc1dd6f6"> 2223</a></span><span class="preprocessor">#define USB_PHY_STATUS_LINE_STATE_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_LINE_STATE_SHIFT) &amp; USB_PHY_STATUS_LINE_STATE_MASK)</span></div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a231364ca810c8ff168d437e990d97349"> 2224</a></span><span class="preprocessor">#define USB_PHY_STATUS_LINE_STATE_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_LINE_STATE_MASK) &gt;&gt; USB_PHY_STATUS_LINE_STATE_SHIFT)</span></div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span> </div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span><span class="comment">/*</span></div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span><span class="comment"> * HOST_DISCONNECT (RW)</span></div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span><span class="comment"> *</span></div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span><span class="comment"> */</span></div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abad24f8e1d37e8d7c827e8dd8046a8ed"> 2230</a></span><span class="preprocessor">#define USB_PHY_STATUS_HOST_DISCONNECT_MASK (0x20U)</span></div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a7f61d2e77e85eca55cda24924cb293de"> 2231</a></span><span class="preprocessor">#define USB_PHY_STATUS_HOST_DISCONNECT_SHIFT (5U)</span></div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2f856dbfaa131340cacc407284a5a010"> 2232</a></span><span class="preprocessor">#define USB_PHY_STATUS_HOST_DISCONNECT_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_HOST_DISCONNECT_SHIFT) &amp; USB_PHY_STATUS_HOST_DISCONNECT_MASK)</span></div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a53c3c3afff549ad20d8e9c0cf0d33ad9"> 2233</a></span><span class="preprocessor">#define USB_PHY_STATUS_HOST_DISCONNECT_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_HOST_DISCONNECT_MASK) &gt;&gt; USB_PHY_STATUS_HOST_DISCONNECT_SHIFT)</span></div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span> </div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span><span class="comment">/*</span></div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span><span class="comment"> * ID_DIG (RW)</span></div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"> 2237</span><span class="comment"> *</span></div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span><span class="comment"> */</span></div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1fe6b3eeca91a6b1579f89e920176c70"> 2239</a></span><span class="preprocessor">#define USB_PHY_STATUS_ID_DIG_MASK (0x10U)</span></div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#abef0882c761e2f69d97af3a7b3174d50"> 2240</a></span><span class="preprocessor">#define USB_PHY_STATUS_ID_DIG_SHIFT (4U)</span></div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0e3af819051ed8af0dfc5e7bac67e831"> 2241</a></span><span class="preprocessor">#define USB_PHY_STATUS_ID_DIG_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_ID_DIG_SHIFT) &amp; USB_PHY_STATUS_ID_DIG_MASK)</span></div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a8a7fdaff35957e8f78d7f07ca208c036"> 2242</a></span><span class="preprocessor">#define USB_PHY_STATUS_ID_DIG_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_ID_DIG_MASK) &gt;&gt; USB_PHY_STATUS_ID_DIG_SHIFT)</span></div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span> </div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span><span class="comment">/*</span></div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span><span class="comment"> * UTMI_SESS_VALID (RW)</span></div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span><span class="comment"> *</span></div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span><span class="comment"> */</span></div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a1d987fb89bc3ee640189530b8d88536c"> 2248</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_SESS_VALID_MASK (0x4U)</span></div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5548aa0c104598797b08c4fbda18795b"> 2249</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_SESS_VALID_SHIFT (2U)</span></div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a054a9bb8e9b55291313f12f1b6418893"> 2250</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_SESS_VALID_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_UTMI_SESS_VALID_SHIFT) &amp; USB_PHY_STATUS_UTMI_SESS_VALID_MASK)</span></div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6cfdc1fcecab99e98c2cd9eb39267bad"> 2251</a></span><span class="preprocessor">#define USB_PHY_STATUS_UTMI_SESS_VALID_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_UTMI_SESS_VALID_MASK) &gt;&gt; USB_PHY_STATUS_UTMI_SESS_VALID_SHIFT)</span></div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span> </div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span><span class="comment">/*</span></div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span><span class="comment"> * VBUS_VALID (RW)</span></div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span><span class="comment"> *</span></div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span><span class="comment"> */</span></div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a46416582d5d71641630f3fcad11b38eb"> 2257</a></span><span class="preprocessor">#define USB_PHY_STATUS_VBUS_VALID_MASK (0x1U)</span></div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a00df3c6158265a08745f48d4252cfb6a"> 2258</a></span><span class="preprocessor">#define USB_PHY_STATUS_VBUS_VALID_SHIFT (0U)</span></div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#afabf877df504e7a63e1bdc3d5adcb187"> 2259</a></span><span class="preprocessor">#define USB_PHY_STATUS_VBUS_VALID_SET(x) (((uint32_t)(x) &lt;&lt; USB_PHY_STATUS_VBUS_VALID_SHIFT) &amp; USB_PHY_STATUS_VBUS_VALID_MASK)</span></div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0c0ab62627ef069806784e60d5b52769"> 2260</a></span><span class="preprocessor">#define USB_PHY_STATUS_VBUS_VALID_GET(x) (((uint32_t)(x) &amp; USB_PHY_STATUS_VBUS_VALID_MASK) &gt;&gt; USB_PHY_STATUS_VBUS_VALID_SHIFT)</span></div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span> </div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span> </div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span> </div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span><span class="comment">/* ENDPTCTRL register group index macro definition */</span></div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a090f5c28c9178716904a91c952df7a2b"> 2265</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL0 (0UL)</span></div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a45d57906aaf4f19925ae48877aea4392"> 2266</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL1 (1UL)</span></div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a56ef65d3218c68d91d87283e94ac97b5"> 2267</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL2 (2UL)</span></div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a3523361d8c9bccc3b810720fbb4ba707"> 2268</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL3 (3UL)</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a2ffc457072be288c406ecc8bf340d5bc"> 2269</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL4 (4UL)</span></div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a0be67db2071e2f2e200bd8fd7a2147c6"> 2270</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL5 (5UL)</span></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#af22890fe59f058ea0e84b9d3c73d568f"> 2271</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL6 (6UL)</span></div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a007b88898f11a0d929d31176be37bda1"> 2272</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL7 (7UL)</span></div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a854a53b08995287ab6ae20dd2874f075"> 2273</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL8 (8UL)</span></div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a974b46a04b4d2c26a19cc2326b190b5b"> 2274</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL9 (9UL)</span></div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a93e968b4ee09cdd01a9dad835939b0e0"> 2275</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL10 (10UL)</span></div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a6bda4c61f7e33634e7cd4d9f1fde96a8"> 2276</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL11 (11UL)</span></div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ac118b75e5994d6750febe15bc482be39"> 2277</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL12 (12UL)</span></div>
<div class="line"><a id="l02278" name="l02278"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a39d0e0cc7d04c4913f2c9d83b6fae873"> 2278</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL13 (13UL)</span></div>
<div class="line"><a id="l02279" name="l02279"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#ab5365a6bd15eca98c00b065b50a63ee7"> 2279</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL14 (14UL)</span></div>
<div class="line"><a id="l02280" name="l02280"></a><span class="lineno"><a class="line" href="HPM6800_2ip_2hpm__usb__regs_8h.html#a5d506241ef52e2ad73ec4f25f558d09e"> 2280</a></span><span class="preprocessor">#define USB_ENDPTCTRL_ENDPTCTRL15 (15UL)</span></div>
<div class="line"><a id="l02281" name="l02281"></a><span class="lineno"> 2281</span> </div>
<div class="line"><a id="l02282" name="l02282"></a><span class="lineno"> 2282</span> </div>
<div class="line"><a id="l02283" name="l02283"></a><span class="lineno"> 2283</span><span class="preprocessor">#endif </span><span class="comment">/* HPM_USB_H */</span><span class="preprocessor"></span></div>
<div class="ttc" id="astructUSB__Type_html"><div class="ttname"><a href="structUSB__Type.html">USB_Type</a></div><div class="ttdef"><b>Definition</b> hpm_usb_regs.h:12</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_19d806e154b23a5f4c4c08b2e30365a6.html">soc</a></li><li class="navelem"><a class="el" href="dir_167cfdde21eabf48398f9683f9505c8f.html">HPM6800</a></li><li class="navelem"><a class="el" href="dir_7e7cf4a74d6064280ca5f49b65fc101b.html">ip</a></li><li class="navelem"><a class="el" href="HPM6800_2ip_2hpm__usb__regs_8h.html">hpm_usb_regs.h</a></li>
    <li class="footer">Generated on Mon Dec 30 2024 18:51:58 for HPM SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
